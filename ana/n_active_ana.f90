! coded on 2021.12.18
! calculation of EM fields generated by finite elngth electric dipole
program ana_active
use param_active_ana ! see m_param_active_ana.f90
use m_param_ana        ! see m_param_ana.f90
implicit none
type(param_forward_ana) :: g_param_ana ! see m_param_active_ana.f90
type(param_source)      :: sparam
type(respdata),allocatable,dimension(:,:,:) :: resp5
integer(4)              :: nfreq,j,nsr,nobs
real(8)                 :: freq

!#[1]## read param from ctl file
 call readparam_ana(g_param_ana,sparam)
 nfreq = g_param_ana%nfreq
 nsr   = sparam%nsource
 nobs  = g_param_ana%nobs
 write(*,*) "nfreq",nfreq
 write(*,*) "nsr",nsr
 write(*,*) "nobs",nobs

!#[2]## set param as global parameters
 call setparams(g_param_ana,sparam) ! change global variables

!#[3]## allocate resp data
  allocate(resp5(5,nsr,nfreq))
  CALL ALLOCATERESP(nobs,nsr,resp5,nfreq)

!#[4]## calculation
 do j=1,nfreq
  freq=g_param_ana%freq(j)
  write(*,*) j,"freq",freq,"[Hz]"
  call forward(g_param_ana,sparam,freq,resp5(:,:,j))
 end do

!#[5]## output resp to obs file
 CALL OUTOBSFILESFWD(g_param_ana,sparam,nsr,resp5,nfreq) !2017.07.11 m_outresp.f90

end program

!#############################################
!# copied from 2018.02.22
!# modified on 2017.10.12
!# modified on 2017.07.11 to include nsr
!# coded    on 2017.05.31
subroutine ALLOCATERESP(nobs,nsr,resp,nfreq)
use param_active_ana
implicit none
integer(4),         intent(in)    :: nobs
integer(4),         intent(in)    :: nsr ! 2017.07.11
integer(4),         intent(in)    :: nfreq
type(respdata),     intent(inout) :: resp(5,nsr,nfreq) !2017.07.11
integer(4)                        :: i,j,k

do j=1,nfreq
 do i=1,5
  do k=1,nsr ! 2017.07.11
   CALL ALLOCATERESPDATA(nobs,resp(i,k,j)) ! 2017.07.11 see m_active_ana.f90
  end do     ! 2017.07.11
 end do
end do

 write(*,*) "### ALLOCATERESP END!! ###"
return
end

!######################################### OUTOBSFILESFWD 2017.07.11
!# coded on 2017.07.11
subroutine OUTOBSFILESFWD(g_param,sparam,nsr,tresp,nfreq)
use param_active_ana
implicit none
type(param_forward_ana),intent(in) :: g_param
type(param_source),     intent(in) :: sparam
integer(4),             intent(in) :: nsr
integer(4),             intent(in) :: nfreq
type(respdata),         intent(in) :: tresp(5,nsr,nfreq)
character(50)  :: head, sour, site
character(70)  :: filename
integer(4)     :: i,j,k,l,nhead,nsite,nsour,nobs
real(8)        :: freq

!#[1]## set
 nobs  = g_param%nobs
 head  = g_param%outputfolder
 nhead = len_trim(head)

!#[2]##
 do l=1,nobs
  site  = g_param%obsname(l)
  nsite = len_trim(site)

  do k=1,nsr
   sour     = sparam%sourcename(k)
   nsour    = len_trim(sour)
   filename = head(1:nhead)//site(1:nsite)//"_"//sour(1:nsour)//".dat"
   open(31,file=filename)

   do i=1,nfreq
    freq = g_param%freq(i)
    write(31,'(11g15.7)') freq,(tresp(j,k,i)%ftobsamp(l),&
    &                           tresp(j,k,i)%ftobsphase(l),j=1,5)
   end do

   close(31)
  end do
 end do

 write(*,*) "### OUTOBSFILESFWD END!! ###"

return
end subroutine

!###############################################
subroutine forward(g_param_ana,sparam,freq,resp) !2017.07.11
use param_active_ana
use m_param_ana
implicit none
type(param_forward_ana),intent(in)    :: g_param_ana
type(param_source),     intent(in)    :: sparam
type(respdata),         intent(inout) :: resp(5,sparam%nsource)
real(8),                intent(in)    :: freq
real(8),allocatable,dimension(:,:)    :: obsxy
real(8)                               :: exy(2,2),bxyz(3,2) ! amp  uV/m, nT and phase [deg]
real(8)                               :: I,xs1(2),xs2(2),ds,p
integer(4)                            :: nobs,k,j,nsource

!# set
I       = sparam%I
nobs    = g_param_ana%nobs
nsource = sparam%nsource
allocate(obsxy(2,nobs))
obsxy(1:2,1:nobs) = g_param_ana%xyzobs(1:2,1:nobs)*1.d+3 ! [km] -> [m]
ds      = sparam%ds ! [m]

do k=1,nsource
 xs1(1:2) = sparam%xs2(1:2,k)*1.d3
 xs2(1:2) = sparam%xs1(1:2,k)*1.d3
! write(*,*) "source",k
! write(*,*) "xs1",xs1
! write(*,*) "xs2",xs2

do j=1,nobs
 call dipole_l(xs1,xs2,I,ds,obsxy(1:2,j),exy,bxyz,freq) ! see m_hankel_takuto_L.f90
! write(*,*) "CAL END",K,J
 p =180.d0! empirical 2021.12.20
 if (bxyz(3,2)  .gt. 0. ) then ! empirical
   bxyz(3,2)= bxyz(3,2) - 180.
 else
   bxyz(3,2)= bxyz(3,2) + 180.
 end if
 resp(1,k)%ftobsamp(j)   =  bxyz(1,1)  ! bx amp
 resp(1,k)%ftobsphase(j) =  bxyz(1,2) ! bx phase
 resp(2,k)%ftobsamp(j)   =  bxyz(2,1) ! by amp
 resp(2,k)%ftobsphase(j) =  bxyz(2,2) ! by phase
 resp(3,k)%ftobsamp(j)   =  bxyz(3,1) ! bz amp
 resp(3,k)%ftobsphase(j) =  bxyz(3,2) ! bz phase
 resp(4,k)%ftobsamp(j)   =  exy( 1,1) ! ex amp
 resp(4,k)%ftobsphase(j) =  exy( 1,2) ! ex phase
 resp(5,k)%ftobsamp(j)   =  exy( 2,1) ! ey amp
 resp(5,k)%ftobsphase(j) =  exy( 2,2) ! ey phase
 !
end do

end do

return
end

!###############################################
subroutine setparams(g_param_ana,sparam)
use param_active_ana
use m_param_ana
implicit none
type(param_forward_ana),intent(in) :: g_param_ana
type(param_source),     intent(in) :: sparam
integer(4) :: j

nlayer = g_param_ana%nlayer
allocate(h(0:nlayer),cond(0:nlayer))

h(0)      = 999999.d0
h(nlayer) = 999999.d0
cond(0)   = g_param_ana%sigma_air
if ( nlayer .ge. 2) then
 do j=1,nlayer-1
  h(j)    = g_param_ana%sigma_depth(j)*1.d3 ! [km] -> [m]
 end do
end if

do j=1,nlayer
 cond(j) = g_param_ana%sigma(j)
end do

return
end

