! Coded on April 21, 2016
! to calculate analytical solution of electric and magnetic fields generated by
! horizontal electric dipole
! Notes
! 1. horizontal electric dipole points positive x direction
! 2. input z is upward, converted to downward positive z in subroutine
! 3. x direction is the same in both input and used coordinate system
! 4. ground surface is z=0
! 5. half-space 1D structure is given in m_param_ana.f90
!
! INPUT
! x3obs(1:3) : cartesian coordinate of observation point [m]
! I  : electric current [A]
! ds : length of dipole [m]
! freq : frequency [Hz]
! iflag : 1 for primary field, 2 for secondary field, 3 for total field
! iebflag : 1 for magnetic field, 2 for electric field
!
! OUTPUT
! f3(1:3) : complex(8) magnetic [nT] or electric field [uV/m]
!--
! This program is based on 3D_ana_comp/ana/OMSP/hankel_takuto.f90
! Coded on April 7, 2016
! to conduct Hankel transform with OMSP,
! Omura's Mathmatical Source Package
! Found that Ooura's package is much superior to Anderson's code!!!! 2016.04.07
!
! called from CALEPONEDGE in eprimary2.f90
subroutine anahalfspace(x3obs,I,ds,freq,iflag1,iebflag,f3)
!# iflag = 1 for primary, 2 for secondary, 3 for total
!# iebflag = 1 for magnetic field [nT], 2 for electric field [uV/m]
use m_param_ana
implicit none
real(8),intent(in) :: x3obs(3) ! [m]
real(8),intent(in) :: I  ![A]
real(8),intent(in) :: ds ![m]
real(8),intent(in) :: freq ! [Hz]
complex(8),intent(out) :: f3(3) ! e or b
integer(4),intent(in) :: iebflag ! 1 for magnetic field, 2 for electric field
integer(4),intent(in) :: iflag1
!-----
real(8) bz2(2),by0(2),bx2(2),err,ex2(2),ey2(2)
complex(8) :: bz,by,bxj1(2),bx,ex0,exj1(2),eyj1(2),ey0,BYJ1(2)
real(8),external :: funall
integer(4) :: k,l,j,m
integer(4),dimension(2) :: isign=(/1,-1/)
real(8) :: coef, coef2
real(8) :: D=0.01 ! 1cm
!#[0]# upward positive to downward positive
xobs=   x3obs(1) ! [m]
yobs= - x3obs(2) ! [m]
zobs= - x3obs(3) ! [m]
!# irtemflag = 1 for only RTE, 2 for only RTM, 3 for both RTE and RTM
 irtemflag = 2

!#[1]## make coefficient, I*ds*mu/4/pi
 iflag=iflag1 ! 1 for primary, 2 for secondary, 3 for total
 omega=2.*pi*freq
 istructure=1
 y0hat= cond(istructure,0) + iunit*omega*epsilon
 z0hat= iunit*omega*mu
 coef =I*ds*mu/4./pi*1.d+9  ! [nT]
 coef2=I*ds/4.d0/pi *1.d+6  ! [mV/km]

!-----------------------------------------------------------  magnetic field
if ( iebflag .eq. 1) then
 ! BZ
   FNAME="FBZ ";jflag=1
   R=dsqrt(xobs**2.d0+yobs**2.d0) ![m]
   if ( R .eq. 0.d0 ) R=0.001d0 ! 1 mm
    do iflag_realimag=1,2 ! 1 for real, 2 for imaginary
     call intdeo(funall, 0.d0, R, 1.d-10, bz2(iflag_realimag), err)
    end do
    bz=coef*yobs/R*(bz2(1) + iunit*bz2(2))

 ! BY
    FNAME="FBY1";jflag=1
    !# xobs + DX
    do j=1,2
     R=dsqrt((xobs+isign(j)*D)**2.d0+yobs**2.d0)
     do iflag_realimag=1,2 ! 1 for real, 2 for imaginary
      call intdeo(funall, 0.d0, R, 1.d-10, by0(iflag_realimag), err)
     end do
     BYJ1(j) = (xobs+isign(j)*D)/R*(by0(1)+iunit*by0(2)) ! 1 for first order Bessel
    end do
    by= - coef*(BYJ1(1)-BYJ1(2))/(2.*D) ! [nT]
    !#[5-2] J0
    FNAME="FBY0";jflag=0
    R=dsqrt(xobs**2.d0+yobs**2.d0)
    if ( R .eq. 0.d0 ) R=0.001d0 ! 1 mm
    do iflag_realimag=1,2 ! 1 for real, 2 for imaginary
     call intdeo(funall, 0.d0, R, 1.d-10, by0(iflag_realimag), err)
    end do
    by = by - coef*(by0(1)+ iunit*by0(2))

 ! BX
   FNAME="FBX ";jflag=1
     do j=1,2
     R=dsqrt((xobs+isign(j)*D)**2.d0+yobs**2.d0)
     do iflag_realimag=1,2 ! 1 for real, 2 for imaginary
      call intdeo(funall, 0.d0, R, 1.d-10, bx2(iflag_realimag), err)
     end do
     bxj1(j)=coef*yobs/R*(bx2(1) + iunit*bx2(2))
    end do
    bx=(bxj1(1)-bxj1(2))/(2.d0*D)

 f3(1:3)=(/bx,-by,-bz/) ! revert the coordinate system
!-----------------------------------------------------------  electric field
else if (iebflag .eq. 2) then
 !Ex
!    write(*,*) "check1"
    !#[J1]
    FNAME="FEX1";jflag=1
    do j=1,2
     R=dsqrt((xobs+isign(j)*D)**2.d0+yobs**2.d0)
     do iflag_realimag=1,2 ! 1 for real, 2 for imaginary
      call intdeo(funall, 0.d0, R, 1.d-10, ex2(iflag_realimag), err)
     end do
     exj1(j)= (xobs+isign(j)*D)/R*(ex2(1) + iunit*ex2(2))
    end do
    ex0 = - coef2*(exj1(1) - exj1(2))/(2.*D) ! [nT] downward positive
    !#[J0]
    FNAME="FEX0";jflag=0
    R=dsqrt(xobs**2.d0+yobs**2.d0)
    if ( R .eq. 0.d0 ) R=0.001d0 ! 1 mm
    do iflag_realimag=1,2 ! 1 for real, 2 for imaginary
     call intdeo(funall, 0.d0, R, 1.d-10, ex2(iflag_realimag), err)
    end do
    ex0 = ex0 - z0hat*coef2*(ex2(1) + iunit*ex2(2)) ! [nT] downward positive

 !Ey
 !   write(*,*) "check2"
  !#[J1]
  FNAME="FEY1";jflag=1
  do j=1,2
   R=dsqrt((xobs+isign(j)*D)**2.d0+yobs**2.d0) ! [m]
   do iflag_realimag=1,2
    call intdeo(funall,0.d0,R,1.d-10,ey2(iflag_realimag),err)
   end do
   eyj1(j)=yobs/R*(ey2(1)+iunit*ey2(2))
  end do
  ey0 = - coef2*(eyj1(1) - eyj1(2))/(2.d0*D)

f3(1:3)=(/ex0,-ey0,-(0.d0,0.d0)/) ! only for the case the dipole is on z=0 plane
end if

return
end subroutine anahalfspace
!=========================================================== amphase
subroutine amphase(cmp,amp,phase)
use m_param_ana
implicit none
complex(8),intent(in) :: cmp
real(8),intent(out) :: amp,phase
 amp=dsqrt(dreal(cmp)**2.d0 + dimag(cmp)**2.d0)
 phase=datan2(dimag(cmp), dreal(cmp))*r2d
 return
end

!################################### funall
function funall(G0)
 use m_param_ana
 implicit none
 real(8),intent(in) :: G0
 real(8) funall
 real(8),external :: dbesj0,dbesj1
 COMPLEX(8) :: FBZ,FBX,FBY0,FBY1,FEX0,FEX1,FEY1
 complex(8) FUN
 !#[1]# choose function and calculate
  if ( FNAME .eq. "FBZ   ") FUN=FBZ(G0)
  if ( FNAME .eq. "FBX   ") FUN=FBX(G0)
  if ( FNAME .eq. "FBY0  ") FUN=FBY0(G0)
  if ( FNAME .eq. "FBY1  ") FUN=FBY1(G0)
  if ( FNAME .eq. "FEX0  ") FUN=FEX0(G0)
  if ( FNAME .eq. "FEX1  ") FUN=FEX1(G0)
  if ( FNAME .eq. "FEY1  ") FUN=FEY1(G0)

 !#[2]# real or imag
  if (iflag_realimag .eq. 1)  funall=dreal(FUN) ! real
  if (iflag_realimag .eq. 2)  funall=dimag(FUN) ! imaginary

 !#[3]# J0 or J1
  if (jflag .eq. 0)   funall=funall*dbesj0(R*G0) ! real
  if (jflag .eq. 1)   funall=funall*dbesj1(R*G0) ! imaginary

end function funall

!# Coded on Dec. 1, 2015
!========================================================== FBX
!# see Ward and Hohmann (1988), p.233
complex(8) function FBX(G0)
use m_param_ana
real(8),intent(in) :: G0
  CALL CALRTEM(G0) ! get G, G2, RTE, RTM, u0 from G0
  if (iflag .eq. 1) FBX=0.d0
!  if (iflag .ne. 1) FBX= (RTM + RTE)*cdexp(u0*zobs)
  if (iflag .ne. 1) FBX= (RTM + RTE)
  FBX=FBX*expuz() ! see m_param_ana.f90
return
end
!========================================================== FBY1
complex(8) function FBY1(G0)
use m_param_ana
real(8),intent(in) :: G0
  CALL CALRTEM(G0) ! get G, G2, RTE, RTM, u0 from G0
  if (iflag .eq. 1) FBY1=0.d0
!  if (iflag .ne. 1) FBY1= (RTM + RTE)*cdexp(u0*zobs) ! RTM + RTE
  if (iflag .ne. 1) FBY1= (RTM + RTE) ! RTM + RTE
  FBY1=FBY1*expuz() ! see m_param_ana.f90
return
end
!========================================================== FBY0
complex(8) function FBY0(G0)
use m_param_ana
real(8),intent(in) :: G0
  CALL CALRTEM(G0) ! get G, G2, RTE, RTM, u0 from G0
!  if (iflag .eq. 1) FBY0 = 1.0 *cdexp(u0*zobs)*G
!  if (iflag .eq. 2) FBY0= - RTE*cdexp(u0*zobs)*G
!  if (iflag .eq. 3) FBY0= (1.0 - RTE)*cdexp(u0*zobs)*G
  if (iflag .eq. 1) FBY0 = 1.0       *G
  if (iflag .eq. 2) FBY0= - RTE      *G
  if (iflag .eq. 3) FBY0= (1.0 - RTE)*G
  FBY0=FBY0*expuz() ! see m_param_ana.f90
return
end
!========================================================== FBZ
!# see Ward and Hohmann (1988), p.233
complex(8) function FBZ(G0) ! G0 is lambda
use m_param_ana
real(8),intent(in) :: G0
  CALL CALRTEM(G0)
!  if (iflag .eq. 1)  FBZ=        1.d0 *cdexp(u0*zobs)*G2/u0
!  if (iflag .eq. 2)  FBZ=         RTE *cdexp(u0*zobs)*G2/u0
!  if (iflag .eq. 3)  FBZ= (1.d0 + RTE)*cdexp(u0*zobs)*G2/u0
  if (iflag .eq. 1)  FBZ=        1.d0 *G2/u0
  if (iflag .eq. 2)  FBZ=         RTE *G2/u0
  if (iflag .eq. 3)  FBZ= (1.d0 + RTE)*G2/u0
  FBZ=FBZ*expuz() ! see m_param_ana.f90
return
end
!========================================================== FEX1
!# see Ward and Hohmann (1988), p.233
complex(8) function FEX1(G0)
use m_param_ana
real(8),intent(in) :: G0
  CALL CALRTEM(G0)
  if (iflag .eq. 1)  FEX1=  1.d0      *u0/y0hat -  1.d0     *z0hat/u0
  if (iflag .eq. 2)  FEX1=      - RTM *u0/y0hat -       RTE *z0hat/u0
  if (iflag .eq. 3)  FEX1= (1.d0- RTM)*u0/y0hat - (1.d0+RTE)*z0hat/u0
  FEX1=FEX1*expuz() ! see m_param_ana.f90
return
end
!========================================================== FEX0
!# see Ward and Hohmann (1988), p.233
complex(8) function FEX0(G0)
use m_param_ana
real(8),intent(in) :: G0
  CALL CALRTEM(G0)
  if (iflag .eq. 1)  FEX0=  1.d0       *G/u0
  if (iflag .eq. 2)  FEX0=         RTE *G/u0
  if (iflag .eq. 3)  FEX0= (1.d0 + RTE)*G/u0
  FEX0=FEX0*expuz() ! see m_param_ana.f90
return
end
!========================================================== FEY1
!# see Ward and Hohmann (1988), p.233
complex(8) function FEY1(G0)
use m_param_ana
real(8),intent(in) :: G0
  CALL CALRTEM(G0)
  if (iflag .eq. 1)  FEY1=  1.d0      *u0/y0hat -  1.d0     *z0hat/u0
  if (iflag .eq. 2)  FEY1=      - RTM *u0/y0hat -       RTE *z0hat/u0
  if (iflag .eq. 3)  FEY1= (1.d0- RTM)*u0/y0hat - (1.d0+RTE)*z0hat/u0
  FEY1=FEY1*expuz() ! see m_param_ana.f90
return
end

!===========================================================  RTE and RTM
subroutine CALRTEM(G0)
use m_param_ana
implicit none
real(8),intent(in)  :: G0
complex(8) :: Y_hat(0:nlayer), Y(0:nlayer),u(0:nlayer)
complex(8) :: Z_hat(0:nlayer), Z(0:nlayer), th, k2
integer(4) :: j
  G=G0 ; G2=G*G

!#[1]## coefficients, G2, u, Y=u/i/omega/mu
 do j=0,nlayer
  k2=-iunit*mu*omega*(cond(istructure,j)+iunit*omega*epsilon)
  u(j)=cdsqrt(G2-k2)
  Y(j)=u(j)/(iunit*omega*mu)
  Z(j)=u(j)/(cond(istructure,j)+iunit*omega*epsilon)
 end do
!#[2]## RTE and RTM
 Y_hat(nlayer)=Y(nlayer)
 Z_hat(nlayer)=Z(nlayer)
 do j=nlayer-1, 1, -1
  Y_hat(j)=Y(j)*(Y_hat(j+1)+Y(j)      *th(u(j)*h(j)))&
  &            /(Y(j)      +Y_hat(j+1)*th(u(j)*h(j)))
  Z_hat(j)=Z(j)*(Z_hat(j+1)+Z(j)      *th(u(j)*h(j)))&
  &            /(Z(j)      +Z_hat(j+1)*th(u(j)*h(j)))
 end do
 RTE=(Y(0)-Y_hat(1))/(Y(0)+Y_hat(1))
 RTM=(Z(0)-Z_hat(1))/(Z(0)+Z_hat(1))
 if ( irtemflag .eq. 1 ) RTM=(0.d0,0.d0) ! 1 for only RTE
 if ( irtemflag .eq. 2 ) RTE=(0.d0,0.d0) ! 2 for only RTM
 u0=u(0)
 u1=u(1)
return
end

!########################################################### tanh
      function th(a)
      implicit real(selected_real_kind(8))(a-h,o-z)
      complex(8) :: th,a
      th=(1.d0 - cdexp(-2.*a))/(1.d0 + cdexp(-2.*a))
      return
      end
