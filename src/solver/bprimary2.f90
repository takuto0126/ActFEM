! modified on March 23, 2016
! to use Ward and Hohmann (1988) with frequency info
! assuming the non-negligible i*omega*epsiron term
! modified on March 3, 2016
! to adjust to the vector fem
!--------------------------------------------------------------------------
!# converted to subroutine on Jan. 18, 2016
!--------------------------------------------------------------------------
!# Coded on by Takuto MINAMI on Nov. 20, 2015
!# Here is ~/study/volcano/3Dtest/
!# This program calculates primary magnetic field generated by wire current
subroutine bprimary2(l_line,h_mesh,sparam,freq,bpedge)
use mesh_type ! see m_mesh_type.f90
use param     ! see m_param.f90
use line_type ! see m_line.f90
implicit none
type(line_info),   intent(in)  :: l_line
type(mesh),        intent(in)  :: h_mesh
type(param_source),intent(in)  :: sparam
complex(8),        intent(out) :: bpedge(l_line%nline)
real(8),intent(in) :: freq ! Hz
real(8)    :: xs1(3),xs2(3),I
integer(4) :: iflag,jflag
complex(8) :: unit=(1.d0,0.d0)
character(50) :: bpvfile="bpvector.msh"

!#[1]## set source parameters
xs1(1:3)=sparam%xs1(1:3) ! [km]
xs2(1:3)=sparam%xs2(1:3) ! [km]
I       =sparam%I        ! [A]

!#[2]## Calculate bprimary using subroutine magfromwirecurrent(magfromwirecurrent.f90)
CALL CALBPONEDGE(l_line,h_mesh%xyz,h_mesh%node,bpedge,xs1,xs2,I,freq) ! bpedge [nT*km]

!#[3]## Output b3 field to file
iflag=1 ! 1:real, 2:imaginary
jflag=1 ! 1:line-integrated, 2: not integrated
CALL OUTELEMCVEC(bpvfile,bpedge*unit,l_line,h_mesh,iflag,jflag)! 1 for real

write(*,*) "### BPRIMARY END!! ###"

return
end subroutine bprimary2

!########################################  CALBPONEDGE
subroutine CALBPONEDGE(l_line,xyzg, nodeg, bpedge, xs1, xs2, I,freq)
use outerinnerproduct
use line_type ! see m_line_type.f90
implicit none
type(line_info),intent(in) :: l_line
integer(4),     intent(in) :: nodeg
real(8),intent(in) :: freq
real(8),intent(in)  :: I  ! [A]
real(8),intent(in)  :: xs1(3),xs2(3) ! [km]
real(8),intent(in)  :: xyzg(3,nodeg) ! [km]
complex(8),intent(out) :: bpedge(l_line%nline) ! [nT*km]
integer(4) :: j, n1, n2, nline
integer(4) :: line(2,l_line%nline)
real(8)    :: x3(3),x1(3),x2(3) ! [m]
real(8)    :: vec(3),  veclen
complex(8) :: b3(3)
integer(4)    :: ntimes=20

!#[0]## set
nline=l_line%nline
line(1:2,1:nline)=l_line%line(1:2,1:nline)

!#[1]## calculate bpedge
do j=1,nline
 n1=line(1,j)
 n2=line(2,j)

 !#[1-1]# unit vector along the line
 vec(1:3)=xyzg(1:3,n2)-xyzg(1:3,n1) ! [km]
 veclen=dsqrt(vec(1)**2.d0 + vec(2)**2.d0 + vec(3)**2.d0) ! [km]
 vec(1:3)=vec(1:3)/veclen ! unit vector [dimension less]

 !#[1-2]# component pallarel to the line
 x3(1:3)=(xyzg(1:3,n2) + xyzg(1:3,n1))/2.d0 * 1000.d0 ! [m]
 x1(1:3)=xs1(1:3)*1.d3       ! [m]
 x2(1:3)=xs2(1:3)*1.d3       ! [m]
 CALL magfromwirecurrent(x3,x1,x2,I,ntimes,b3(1:3),freq) ! b3 [nT]
 bpedge(j)= inner_rc(vec,b3)*veclen ! [nT*km] component along vec
! write(*,*) "j=",j,"bpedge(j)=",bpedge(j),"x3(1:3)=",x3(1:3),"x1=",x1,"x2=",x2,"I=",I
end do

write(*,*) "### CALBPONEDGE END!! ###"
return
end

!######################################## OUTELEMECVEC
!# modified on March, 3, 2016, to use modules
!# coded on Nov. 27, 2015
!# iflag=1 : real, 2: imag
!# jflag=1 : line-integrated, 2: not integrated
subroutine OUTELEMCVEC(filename,bedge,l_line,h_mesh,iflag,jflag)
use mesh_type     ! for mesh,see m_mesh_type.f90
use line_type          ! for kl , see m_line_type.f90
use fem_edge_util ! for EDGEBASISFUN, see m_fem_edge_util.f90
implicit none
type(mesh),intent(in) :: h_mesh
type(line_info),  intent(in) :: l_line
complex(8),       intent(in) :: bedge(l_line%nline) ! [nT]
character(50),    intent(in) :: filename
integer(4),       intent(in) :: iflag  ! 1:real, 2:imaginary
integer(4),       intent(in) :: jflag  ! 1:line-integrated value, 2:not integrated
integer(4) :: node,ntet,ishift
integer(4) :: n6line(h_mesh%ntet,6),n4(h_mesh%ntet,4)
integer(4) :: i,j,k,ifile
real(8)    :: x3(3),len(6),w(3,6),xyz(3,h_mesh%node),elm_xyz(3,4),v
complex(8) :: b3(3)

!#[0]## set
node            = h_mesh%node
ntet            = h_mesh%ntet
xyz(1:3,1:node) = h_mesh%xyz
n4(1:ntet,1:4)  = h_mesh%n4(1:ntet,1:4)
n6line(1:ntet,1:6)= l_line%n6line(1:ntet,1:6)
ishift          = h_mesh%npoi + h_mesh%nlin + h_mesh%ntri

!#[1]## check iflag
if (iflag .ne. 1 .and. iflag .ne. 2 ) goto 999

!#[2]## open file
ifile=1
open(ifile,file=filename)

!#[3]## out meshinfo
CALL MESHOUT(ifile,h_mesh) ! header, node, element are output

!#[4]## create vector fields
write(1,'(a)') "$ElementData"
write(1,'(a)') "1"
write(1,'(a)') '"A vector view"'
write(1,'(a)') "1"
write(1,'(a)') "0.0"
write(1,'(a)') "3"
write(1,'(a)') "0"
write(1,'(a)') "3"
write(1,*) ntet

!#[5]
do i=1,ntet

 !#[5-1]# set x3 and elm_xyz
 x3(:)=0.d0
 do j=1,4
  x3(:)         = x3(:) + xyz(:,n4(i,j))/4.d0 ! center of gravity
  elm_xyz(1:3,j)= xyz(1:3,n4(i,j))
 end do

 !#[5-2]# get w and len
 CALL EDGEBASISFUN(elm_xyz,x3,w,len,v) ! v[km]^3, w[1/km], len[km]

 !#[5-3]# cal b3
 b3(:)=(0.d0,0.d0)
 do j=1,6
  if ( jflag .eq. 1) then     ! line-integrated
   b3(1:3)=b3(1:3) + w(1:3,j)*bedge(abs(n6line(i,j)))*isign(1, n6line(i,j))
  else if (jflag .eq. 2) then ! not integrated
   b3(1:3)=b3(1:3) + w(1:3,j)*bedge(abs(n6line(i,j)))*isign(1, n6line(i,j))*len(j)
  else
   goto 99
  end if
 end do
! call checkvalues(i,ntet,b3,w,len,elm_xyz)

 !#[5-4]# out b3
 if (iflag .eq. 1 ) then ! real part
  write(ifile,*) ishift+i, dreal(b3(1)),dreal(b3(2)),dreal(b3(3))
 else                    ! imaginary
  write(ifile,*) ishift+i, dimag(b3(1)),dimag(b3(2)),dimag(b3(3))
 end if

end do

write(ifile,'(a)') "$EndElementData"
close(ifile)

write(*,*)"### OUTPUT TO ",filename(1:len_trim(filename))," END! ###"
return

! error
999 continue
 write(*,*) "GEGEGE! iflag should be 1 (real) or 2(imag), iflag=",iflag
 stop
99 continue
 write(*,*) "GEGEGE! jflag should be 1 (integrated) or 2(not integrated)"
 write(*,*) "jflag=",jflag
 stop
end
!
!#######
subroutine checkvalues(iele,ntet,b3,w,len,elm_xyz)
implicit none
integer(4),intent(in) :: iele,ntet
real(8),intent(in) :: len(6),elm_xyz(3,4),w(3,6)
complex(8),intent(in) :: b3(3)
integer(4) :: i
 write(*,*) "iele=",iele,"ntet=",ntet
 do i=1,4
  write(*,*) "elm_xyz(1:3,i)=",elm_xyz(1:3,i)
 end do
 do i=1,3
 write(*,*) "b3(1:3)=",b3(i)
 end do
 do i=1,6
 write(*,*) "w(1:3,1:6)=",w(1:3,i)
 end do
 do i=1,6
 write(*,*) "len(i)=",len(i)
 end do
return
end
!#######################################################################
subroutine MAGFROMWIRECURRENT(x3m, xs1m, xs2m, I, ntimes, b3,freq)
implicit none
real(8),intent(in) :: x3m(3), xs1m(3), xs2m(3) ![m]
real(8),intent(in) :: freq ! [Hz]
real(8),intent(in) :: I ![A]
integer(4),intent(in) :: ntimes
complex(8), intent(out), dimension(3) :: b3
!# Scaling parameter
real(8), parameter :: pi=4.d0*datan(1.d0), mu=4.d0*pi*1.d-7
real(8), parameter :: epsiron=8.854187817*1.d-12
real(8), parameter :: R0=1000.d0 ! [m]
real(8)  :: x3(3), xs1(3), xs2(3) ! [km]
real(8) ::  COEF=mu/4.d0/pi/R0*1.d+9 ! mu/4pi/nano/R0 [nT]
!# only in this subroutine
complex(8) :: k,A,iunit=(0.d0,1.d0)
real(8) :: omega, r ! [m]
real(8) :: sigma
real(8) :: dxs3(3), o2obsvec(3), wirelength, xorigin3(3), distance, dl
real(8) :: xorigin3_local(3), o2obsvec_local(3),xs1_local(3), xs2_local(3)
real(8) :: A1, B1, distance_local, dlvec(3), dlcrossr(3)
integer(4) :: j, n
omega=2.d0*pi*freq ! [rad/s]
sigma=1.d-8 ! [S/m]

!#[0]## scaling
x3(1:3)=x3m(1:3)/R0    ! x3  [km] observation point
xs1(1:3)=xs1m(1:3)/R0  ! xs1 [km] start point
xs2(1:3)=xs2m(1:3)/R0  ! xs2 [km] end point

!#[1]## generate some parameters
xorigin3(1:3)=( xs2(1:3) + xs1(1:3) )/2.d0  ! [km]
dxs3(1:3)=xs2(1:3) - xs1(1:3)               ! [km]
!write(*,*) "dxs3=",dxs3(1:3),"[km]"
wirelength=dsqrt(dxs3(1)**2.d0 + dxs3(2)**2.d0 + dxs3(3)**2.d0) ! [km]
!write(*,*) "wirelength=",wirelength,"[km]"
o2obsvec(1:3)=x3(1:3)-xorigin3(1:3)         ! r when n=1 [km]
distance=dsqrt(o2obsvec(1)**2.d0 + o2obsvec(2)**2.d0 + o2obsvec(3)**2.d0) ! [km]

!#[2]## search how many partitions are required
n=1
if ( wirelength*ntimes .gt. distance ) n=wirelength/distance*ntimes + 1
dlvec=dxs3/float(n)
!if ( n .ge. 2) write(*,*) "# of dipole is", n, "for the point of", x3(1:3)

!#[3]## calculate b3
!#       | n|.. |j|..| 2| 1|
!#    xs2|<----------------|xs1
!#       | 1-A1   |  A1    |    A1=(j-1)/n
!#       | 1-B1 |  B1      |    B1= j/n
!#           xs2_local
!#               xs1_local
b3(1:3)=0.d0
do j=1,n
  A1=float(j-1)/float(n)
  B1=float(j)  /float(n)
  xs1_local(1:3)=A1*xs2(1:3) + (1.d0 - A1)*xs1(1:3)   ! [km]
  xs2_local(1:3)=B1*xs2(1:3) + (1.d0 - B1)*xs1(1:3)   ! [km]
  xorigin3_local(1:3)=(xs1_local(1:3) + xs2_local(1:3))/2.d0  ! [km]
  o2obsvec_local(1:3)=x3(1:3) - xorigin3_local(1:3)   !  [km]
  distance_local=dsqrt(o2obsvec_local(1)**2.d0 + o2obsvec_local(2)**2.d0 + o2obsvec_local(3)**2.d0)
!  write(*,*) "distace_local=",distance_local,"[km]"
!  write(*,*) "dlvec=",dlvec(1:3)
!  write(*,*) "o2obsvec_local(1:3)=",o2obsvec_local(1:3)
  dlcrossr(1)=dlvec(2)*o2obsvec_local(3) - dlvec(3)*o2obsvec_local(2)
  dlcrossr(2)=dlvec(3)*o2obsvec_local(1) - dlvec(1)*o2obsvec_local(3)
  dlcrossr(3)=dlvec(1)*o2obsvec_local(2) - dlvec(2)*o2obsvec_local(1)
!  write(*,*) "dlcrossr=",dlcrossr(1:3)
! Ward and Hohmann (1988)
r=distance_local*1.d3 ! [m]
!k=cdsqrt(-iunit*omega*mu*(0.d0+iunit*omega*epsiron))
k=cdsqrt(-iunit*omega*mu*sigma) ! Pseud steady approximation (Murakami, 1986)
A=(iunit*k*r + 1.d0)*cdexp(-iunit*k*r)
! H=1/4/pi/r^2*(i*k*r+1)*exp(-i*k*r)*(I*dl\timesr)/r
!  b3(1:3)=b3(1:3)+COEF*I*dlcrossr(1:3)/(distance_local**3.d0)
   b3(1:3)=b3(1:3)+A*COEF*I*dlcrossr(1:3)/(distance_local**3.d0)
!  write(*,*) "b3 =",b3(1:3)
!  stop
end do
return
end