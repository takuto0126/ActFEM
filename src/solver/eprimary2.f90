! based on bprimary.f90
! to calculate
! E_p = - 1/(4*pi*r)*I(dsx,dsy,dsz)*exp(-ikr) under vaccume condition
! k=sqrt(-i*omega*mu*(sigma + i*omega*epsilon))
subroutine eprimary(l_line,h_mesh,sparam,freq,epedge)
use mesh_type ! see m_mesh_type.f90
use param     ! see m_param.f90
use line_type ! see m_line.f90
implicit none
type(line_info),   intent(in)  :: l_line
type(mesh),        intent(in)  :: h_mesh
type(param_source),intent(in)  :: sparam
real(8),           intent(in)  :: freq
complex(8),        intent(out) :: epedge(l_line%nline)
real(8)    :: xs1(3),xs2(3),I
integer(4) :: iflag,jflag
complex(8) :: unit=(1.d0,0.d0)
character(50) :: epvfile="epvector.msh"

!#[1]## set source parameters
xs1(1:3)=sparam%xs1(1:3) ! [km]
xs2(1:3)=sparam%xs2(1:3) ! [km]
I       =sparam%I        ! [A]

!#[2]## Calculate bprimary using subroutine magfromwirecurrent(magfromwirecurrent.f90)
CALL CALEPONEDGE(l_line,h_mesh%xyz,h_mesh%node,freq,epedge,xs1,xs2,I) ! bpedge [nT*km]

!#[3]## Output b3 field to file
iflag=2 ! 1:real, 2:imaginary
jflag=1 ! 1:line-integrated, 2: not integrated
CALL OUTELEMCVEC(epvfile,epedge,l_line,h_mesh,iflag,jflag)! 1 for real

write(*,*) "### EPRIMARY END!! ###"

return
end subroutine eprimary

!########################################  CALEPONEDGE
subroutine CALEPONEDGE(l_line,xyzg, nodeg, freq, epedge, xs1, xs2, I)
use outerinnerproduct
use line_type ! see m_line_type.f90
implicit none
type(line_info),intent(in) :: l_line
integer(4),     intent(in) :: nodeg
real(8),intent(in)  :: I  ! [A]
real(8),intent(in)  :: xs1(3),xs2(3) ! [km]
real(8),intent(in)  :: xyzg(3,nodeg) ! [km]
real(8),intent(in)  :: freq
complex(8),intent(out) :: epedge(l_line%nline) ! [nT*km]
complex(8) :: e3node(3,nodeg)
integer(4) :: j, n1, n2, nline
integer(4) :: line(2,l_line%nline)
real(8)    :: x3(3),x1(3),x2(3) ! [m]
real(8)    :: vec(3), veclen,ds
complex(8) :: e3(3),et3(3),phi,phi1,phi2
integer(4) :: ntimes=20

!#[0]## set
nline=l_line%nline
line(1:2,1:nline)=l_line%line(1:2,1:nline)
ds=(xs2(1)-xs1(1))*1.d3 ! [m] length of the dipole in positive x

do j=1,nodeg
 if (mod(j,10000) .eq. 0) write(*,*) "j=",j,"nodeg=",nodeg
 x3(1:3)=xyzg(1:3,j)*1.d3 ! [m]
 if (dabs(x3(3)) .lt. 25.d0) CALL anahalfspace(x3,I,ds,freq,3,2,e3node(1:3,j))
 ! 3 for total, 2 for electric field
end do
!#[1]## calculate bpedge
do j=1,nline
 n1=line(1,j)
 n2=line(2,j)

 !#[1-1]# unit vector along the line
 vec(1:3)=xyzg(1:3,n2)-xyzg(1:3,n1) ! [km]
 veclen=dsqrt(vec(1)**2.d0 + vec(2)**2.d0 + vec(3)**2.d0) ! [km]
 vec(1:3)=vec(1:3)/veclen ! unit vector [dimension less]

 !#[1-2]# component pallarel to the line
 x3(1:3)=(xyzg(1:3,n2) + xyzg(1:3,n1))/2.d0 * 1000.d0 ! [m]
 x1(1:3)=xs1(1:3)*1.d3       ! [m]
 x2(1:3)=xs2(1:3)*1.d3       ! [m]
 !#[1-3]elefromwirecurrent output 3 fields et3, e3, and phi, where et3 = e3 + grad phi
 !CALL elefromwirecurrent(xyzg(1:3,n1)*1.d3,x1,x2,I,freq,ntimes,et3,e3,phi1)! phi1 [mV]
 !CALL elefromwirecurrent(xyzg(1:3,n2)*1.d3,x1,x2,I,freq,ntimes,et3,e3,phi2)! phi2 [mV]
 !CALL elefromwirecurrent(x3,x1,x2,I,freq,ntimes,et3,e3,phi) ! e3 [mV/km]
! CALL anahalfspace(x3,I,ds,freq,3,2,e3) ! 3 for total, 2 for electric field
 epedge(j)=inner_rc(vec,(e3node(1:3,n2)+e3node(1:3,n1))/2.d0)*veclen ! [mV/km * km]
! epedge(j)=inner_rc(vec,e3)*veclen ! [mV/km * km] component along vec
! epedge(j)=epedge(j)+(phi2 - phi1) ! guaranteeing the rot free of grad phi
! write(*,*) "j=",j,"bpedge(j)=",bpedge(j),"x3(1:3)=",x3(1:3),"x1=",x1,"x2=",x2,"I=",I
! + delta phi

end do

write(*,*) "### CALEPONEDGE END!! ###"
return
end
!################################################################  ELEFROMWIRECURRENT
subroutine ELEFROMWIRECURRENT(x3m, xs1m, xs2m, I, freq, ntimes, et3,e3,phi)
! Ward and Hohmann (1988)
! In a homogeneous medium, the electric field generated by horizontal electric dipole
! is expressed as:
! when the electric dipole is delta^3(x)*I*ds, ds=[ds,0,0]
! E=I*ds*coef*[(x*x/r^2*u_x + x*y/r^2*u_y + x*z/r^2*u_z)*A + B*u_x]
!
! where coef=1/(4*pi*(sigma+i*omega*epsiron)*r^3)*exp(-i*k*r)
!       A=(-k^2*r^2 +3*i*k*r + 3)
!       B=(k^2*r^2 -  i*k*r - 1)
!  |
!  |ds=(ds_x,ds_y,ds_z)
!  v
! Ex=     | x*x/r^2*A + B  x*y/r^2*A      x*z/r^2*A     |{I*ds_x}
! Ey=coef*| x*y/r^2*A      y*y/r^2*A + B  y*z/r^2*A     |{I*ds_y}
! Ez=     | x*z/r^2*A      z*y/r^2*A      z*z/r^2*A + B |{I*ds_z}
!
! For edge-based FEM, in E=grad phi - i*omega*mu*A, phi should be assigned to node,
! while -i*omega*mu*A is assigned at edge
!
! ## E0 ##
!
! E0x=     | x*x/r^2*A + B  x*y/r^2*A      x*z/r^2*A     |{I*ds_x}
! E0y=coef*| x*y/r^2*A      y*y/r^2*A + B  y*z/r^2*A     |{I*ds_y}
! E0z=     | x*z/r^2*A      z*y/r^2*A      z*z/r^2*A + B |{I*ds_z}
!
! where A=0 and B=k^2*r^2
!
! ## phi ## Under Lorentz gauge, div A + i*omega*mu*Phi=0, here phi corresponds to TM mode
! phi = coef*(-i*k*r -1)*I*[x*ds_x + y*ds_y + z*ds_z]
!
! et3 = e3 + grad phi [mV/km]
! et3 : total electric field at the given point
! e3  : -i*omega*mu*A, at the given point (which should be assigned at edges)
! phi : potential [mV/km * m](which should be assigned on node)
implicit none
real(8),intent(in) :: x3m(3), xs1m(3), xs2m(3) ![m]
real(8),intent(in) :: I ![A]
real(8),intent(in) :: freq ! [Hz]
integer(4),intent(in) :: ntimes
complex(8), intent(out), dimension(3) :: et3,e3
complex(8), intent(out) :: phi
!# Scaling parameter
real(8), parameter :: pi=4.d0*datan(1.d0), mu=4.d0*pi*1.d-7
real(8), parameter :: epsiron=8.854187817*1.d-12 ! [F/m]
real(8)  :: x3(3), xs1(3), xs2(3) ! [m]
real(8) :: x(3),r,dI(3)
complex(8) ::  COEF,z0,y0
!# only in this subroutine
real(8) :: omega, sigma
real(8) :: dxs3(3), o2obsvec(3), wirelength, xorigin3(3), distance, dl
real(8) :: xorigin3_local(3), o2obsvec_local(3),xs1_local(3), xs2_local(3)
real(8) :: A1, B1, distance_local, dlvec(3), dlcrossr(3)
integer(4) :: j, n, l,m
complex(8) :: dmat(3,3),dmatT(3,3),A,B,AT,BT,k,k2,iunit=(0.d0,1.d0)

omega=2.*pi*freq ! [rad]

!#[0]## scaling
x3(1:3)=x3m(1:3)    ! x3  [m] observation point
xs1(1:3)=xs1m(1:3)  ! xs1 [m] start point
xs2(1:3)=xs2m(1:3)  ! xs2 [m] end point

!#[1]## generate some parameters
xorigin3(1:3)=( xs2(1:3) + xs1(1:3) )/2.d0  ! [m]
dxs3(1:3)=xs2(1:3) - xs1(1:3)               ! [m]
!write(*,*) "dxs3=",dxs3(1:3),"[km]"
wirelength=dsqrt(dxs3(1)**2.d0 + dxs3(2)**2.d0 + dxs3(3)**2.d0) ! [m]
!write(*,*) "wirelength=",wirelength,"[m]"
o2obsvec(1:3)=x3(1:3)-xorigin3(1:3)         ! r when n=1 [m]
distance=dsqrt(o2obsvec(1)**2.d0 + o2obsvec(2)**2.d0 + o2obsvec(3)**2.d0) ! [m]

!#[2]## search how many partitions are required
n=1
if ( wirelength*ntimes .gt. distance ) n=wirelength/distance*ntimes + 1
dlvec=dxs3/float(n) ! [m]
!if ( n .ge. 2) write(*,*) "# of dipole is", n, "for the point of", x3(1:3)

!#[3]## calculate b3
!#       | n|.. |j|..| 2| 1|
!#    xs2|<----------------|xs1
!#       | 1-A1   |  A1    |    A1=(j-1)/n
!#       | 1-B1 |  B1      |    B1= j/n
!#           xs2_local
!#               xs1_local
e3(1:3)=0.d0 ; et3(:)=0.d0 ; phi=0.d0
do j=1,n
  A1=float(j-1)/float(n)
  B1=float(j)  /float(n)
  xs1_local(1:3)=A1*xs2(1:3) + (1.d0 - A1)*xs1(1:3)   ! [m]
  xs2_local(1:3)=B1*xs2(1:3) + (1.d0 - B1)*xs1(1:3)   ! [m]
  xorigin3_local(1:3)=(xs1_local(1:3) + xs2_local(1:3))/2.d0  ! [m]
  o2obsvec_local(1:3)=x3(1:3) - xorigin3_local(1:3)   !  [m]
  distance_local=dsqrt(o2obsvec_local(1)**2.d0 + o2obsvec_local(2)**2.d0 + o2obsvec_local(3)**2.d0)  ! [m]
  r   =distance_local         ! [m]
  x(1:3)=o2obsvec_local(1:3)  ! [m]
  dI(1:3)=I*dlvec(1:3)  ! [A*m] dI3 is electric current vector
! Ex=     | x*x/r^2*A + B  x*y/r^2*A      x*z/r^2*A     |{Ix*ds_x}
! Ey=coef*| x*y/r^2*A      y*y/r^2*A + B  y*z/r^2*A     |{Iy*ds_y}
! Ez=     | x*z/r^2*A      z*y/r^2*A      z*z/r^2*A + B |{Iz*ds_z}
! coef=1./4/pi/(sigma+i*omega*epsiron)/r^3*exp(-i*k*r)
! A = -k^2*r^2 + 3*i*k*r +3
! B =  k^2*r^2    -i*k*r -1
sigma=1.d-8
z0=iunit*omega*mu
y0=sigma + iunit*omega*epsiron
k2=-z0*y0
!k2=-iunit*omega*mu*sigma  !"pseud steady approximation" (Murakami,1986)
k=cdsqrt(k2)
COEF=1./4./pi*cdexp(-iunit*k*r)
do l=1,3
 phi=phi + (-iunit*k*r - 1.d0)*COEF/y0*dI(l)*x(l)*1.d3 ! phi [mV/km * km] for et3 = e3 + grad phi
 do m=1,3
  dmat(l,m)  = x(l)*x(m)/r/r * 0.d0 ! only PM
  dmatT(l,m) = x(l)*x(m)/r/r * (z0/r + 3.d0*iunit/r/r*cdsqrt(-z0/y0) + 3./r/r/r/y0) ! PM + TM
  if ( l .eq. m ) dmat(l,m)  =  dmat(l,m) + (-z0/r) ! only PM
  if ( l .eq. m ) dmatT(l,m) = dmatT(l,m) + (-z0/r -iunit/r/r*cdsqrt(-z0/y0)-1./r/r/r/y0)
    e3(l) = e3(l) + COEF*dmat(l,m) *dI(m)*1.d6 ! -i*omega*mu*A [V/m] -> [mV/km]
    et3(l)=et3(l) + COEF*dmatT(l,m)*dI(m)*1.d6 ! -i*omega*mu*A + gradA  [mV/km]
 end do
end do
!
end do ! j loop
return
end subroutine ELEFROMWIRECURRENT