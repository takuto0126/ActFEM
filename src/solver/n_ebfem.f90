! Coded by Takuto MINAMI on 2015.11.21
! This program is based on n_ebfem.f90 in 3Dfwd_minami/n_ebfem.f90
! This is edge-based finite element solver to solve
! int{ (rot w) cdot (rot Bs)/mu }dv + i*omega*sigma*int{w cdot Bs}dv
!                              = - i*omega*sigma*int{w cdot Bp}dv
! where
! w  : vector shape function
! Bp : primary magnetic field generated directly by source current
! Bs : secondary magnetic field generated by induction
! time dependance of Bp, Bs are exp(i*omega*t)
! omega : anguar frequency
! i : imaginary unit
! sigma : conductivity of the medium
! This program assumes n2, n3, n4 are orderd clockwise from the viewpoint of n1
!  tetrahedron composed of nodes, {n1, n2, n3, n4}
! This program requires calculated Bp at all nodes of tetrahedral mesh
!# Modification log
!# On 2015.11.21: Integration using Gaussian points are replaced by analytical ones.
!                 Then this no longer use the tetrai_table.f90
program n_ebfem
use iccg_var_takuto
implicit none
include "../mesh_for_FEM/meshpara.f90" ! zmin, zmax, xout, yout are set in this file
character(50) :: meshfile="../mesh_for_FEM/3dmesh.msh"
character(50) :: bprimaryfile="../mesh_for_FEM/bprimary.dat"
character(50) :: outfile="btotal.dat"
integer(4),  allocatable, dimension(:,:) :: n4g,n3g,n2g
real (8),  allocatable, dimension(:,:) :: xyzg  ! [km]
integer(4),allocatable, dimension(:)   :: n1g
integer(4) :: IPL, nodeg,ntetg,ntrig,nling,npoig,nsele
integer(4),allocatable,dimension(:) :: line_stack, line_item_work, line_item
integer(4),allocatable,dimension(:,:) :: line, n6line
integer(4) :: nline_bc
logical,   allocatable, dimension(:)  :: line_bc
complex(8),allocatable, dimension(:)  :: Avalue_bc
real(8),   allocatable, dimension(:,:):: bp     ! primary b fields on nodes (real)
real(8),   allocatable, dimension(:)  :: bpedge ! bp on edge (real)
complex(8),allocatable, dimension(:)  :: bsedge ! secondary b fields on edge (complex)
complex(8),allocatable, dimension(:)  :: dphi   ! difference of phi at each line (complex)
integer(4), parameter :: maxnline=500000
integer(4) ::   nline, ip, i, j
!real(8), parameter :: pi=4.d0*datan(1.d0),dmu=4.d0*pi*1.d-7
real(8), parameter :: omega=2.*pi*100.d0
!####### direct solver ####
integer(4) :: MB ! bandwidth
complex(8),dimension(:,:),allocatable :: AMB
integer(4) :: IER
integer(4) :: IB
integer(4),allocatable,dimension(:) :: IBC
complex(8),allocatable,dimension(:) :: VIBC
!##### iccg parameter #####
integer(4) :: doftot, iter, error, nset, imaxcorr
character(20) :: PRECOND
real(8) :: resid, sigma_diag, sigma
!
!#[1]## Mesh READ
CALL MSHCOUNT1(meshfile,nodeg,ntetg,ntrig,nling,npoig)  ! npoi = 0 makes no problems
     allocate(xyzg(3,nodeg),n4g(ntetg,5),n3g(ntrig,4),n2g(nling,3),n1g(npoig))
     ! n2g(i,1) is the group id for lines
     ! n2g(i,2:3) is the start and end node ids for i-th lines in source current edges
CALL READMSH2(meshfile,xyzg,nodeg,n4g,n3g,n2g,n1g,ntetg,ntrig,nsele,nling,npoig)

!#[2]## SET LINE INFORMATION
     allocate( line_stack(0:nodeg), line_item_work(maxnline) )
     ! line_stack(i) stores total line numbers until i-th node line group, 
     !                             where all of lines start with i-th node
     ! line_item_work(j) is the end node id for j-th line
     ! NOTE that lines stored in line_stack are ordered by the starting node ids, 
     !                             not related to the source current
CALL MKLINE(line_stack, line_item_work, maxnline, nline, nodeg, ntetg, n4g)
     allocate( line(2,nline), line_item(nline))
     ! line(1:2,i) is the start and end node id for i-th line
     ! line_item(i) is the same as line_item_work(i) except size
CALL SETLINE(line,line_item,nline,line_item_work,maxnline,line_stack,nodeg) ! line from line_item
     deallocate(line_item_work) ! contents are copied to line_item in SETLINE
     allocate( n6line(ntetg,6) )
     ! n6line(i,1:6) is the line id for i-th tetrahedral element
CALL MKN6(ntetg, n4g, n6line, nodeg, line_stack,  nline, line_item)
     deallocate( line_stack, line_item)
CALL sub_tetrcm3_line (6, nline, n6line, line, ntetg, MB) ! upgrade n6line and line
CALL OUTPERMUTEDLINES(n6line,xyzg,nodeg,line,nline, ntetg,n4g) ! output permutedline.msh

!#[3]## Preparation of primary magnetic field
     allocate( bp(3,nodeg), bpedge(nline) ) ! both bp and bpedge are real
CALL READBPRIMARY(bprimaryfile,bp,nodeg)    ! bp(1:nodeg) [nT] at each node
CALL CALBPONEDGE(bpedge,nline,bp,nodeg,line,xyzg,n6line,n4g,ntetg,meshfile)! bpedge(1:nline) [nT*km]

!#[4]## SET Coefficient matrix and Generate Matrix
  !#[4-1] Matrix for induction equation
  ip=0
  CALL SET_ICCG_VAR7_LINE(nline, ntetg, n6line, ip) ! < m_iccg_var_takuto.f90
  CALL SET_ICCG_VAR7_NODE(nodeg, ntetg, n4g(:,2:5),ip)
  CALL SET_ICCG_VAR7_RHS (nodeg, nline, ntetg, n4g(:,2:5), n6line,ip)
  CALL GETBANDWIDTH(MB,n6line,ntetg,nline)
  allocate(AMB(MB,nline)) ; AMB(:,:)=(0.d0,0.d0)

  !#[4-2]## Generate Matrix
  CALL GENMAT(ntetg, n6line, xyzg, n4g, nodeg,omega,nline,pi,dmu,bpedge,bp,AMB,MB)
  CALL GENMAT_DIVCOR(ntetg, n6line, xyzg, n4g, nodeg, nline)

  !#[4-3]## Copy upper triangle to lower driangle
  CALL COPY_UL_ICCG12(nline, istack_u, item_u, aiccg_u, istack_l, item_l, aiccg_l, &
           &                            item_u_tot, item_l_tot, ip)
  CALL COPY_UL_ICCG12(nodeg, INU, IAU, AU, INL, IAL, AL,iau_tot,ial_tot,ip)

!#[5]## Generate Boundary Values
	! nline is total # of lines in .msh file
	! line_bc(i) is logical; .true. indicates the line value is determined,
	!                        if .false.,  no value is prescribed
	! Avalue_bc(i) is the prescribed value for i-th line, 
	!                        which will be used if line_bc(i) = .true.
!#[5-1]## FOR MT
!CALL GENBCMT(line, nline, xyzg, nodeg, n6line, ntetg, omega,  line_bc, Avalue_bc)
    !do i=1,nline_bc
    !write(*,*) "nline_bc(i)=",line_bc(i),"Avalue_bc(i)",Avalue_bc(i)
    !end do
!#[5-1]##  FOR CSEM
    !#[5-1-2]## Dirichlet boundary at calculation boundaries
	allocate(line_bc(nline), Avalue_bc(nline))
CALL GENBCCSEM(zmin, zmax, xout, yout, line, nline, xyzg, nodeg, Avalue_bc,line_bc,IB)

!#[6]## Set Boundary Condition for dirichlet boundary
!#[6-1]## for CG
CALL SET_BC_ICCG( aiccg_u, diag, item_u, istack_u, item_u_tot, &
&  aiccg_l, item_l, istack_l, item_l_tot, nline, b_vec, &
&  Avalue_bc, line_bc, ip)

!#[6-2]## Set boundary condition for SOLVC2
   allocate(VIBC(IB),IBC(IB))
   J=0
   do i=1,nline
    if (line_bc(i)) then
    J=J+1 ; IBC(J)=i ; VIBC(J)=Avalue_bc(i) ! VIBC(J)=(0.d0,0.d0)
    end if
   end do
CALL SETBC( AMB , b_vec ,MB, MB , nline , IB , IBC , VIBC )
deallocate(line_bc, Avalue_bc)
deallocate( VIBC,IBC)

!#[7]## Solve
!#[7-1]## Direct solver
!do i=1,nline
!write(*,*) "b_vec(i)=",b_vec(i),"AMB(1,i)=",AMB(1,i),"xyz=",xyzg(1:3,line(1,i))
!end do

CALL SOLVC2( AMB , b_vec , nline ,MB, MB , IER , 0 )
x_vec=b_vec
goto 200

!#[7-2] CG
allocate( dphi(nline) )
x_vec(:)=0.d0
imaxcorr=1000
do i=1,imaxcorr
 doftot=nline
 PRECOND="SSOR"
 RESID=1.e-20        ! convergence tol.
 SIGMA_DIAG=1.0    ! diag. mul.
 SIGMA=0.0               ! non-diag. mul.
 ERROR=0                  ! error id (inout)
 nset=1                     ! precondition 0: no, 1: yes, 2: scaling
!ITER=2000
 ITER=10    ! max iteration, or the iteration number per which divergence correction is conducted
 CALL  CG13_single_cpx  (doftot,  item_l_tot, item_u_tot,    &
     &                  diag,  aiccg_l, istack_l, item_l, aiccg_u, istack_u, item_u, &
     &                  b_vec,  x_vec, precond, sigma_diag, sigma,                   &
     &                  resid,  iter, error,  NSET)
 if ( RESID .lt. 1.e-20 ) goto 100

 !#[7-2] Divergence correction
 write(*,*) "Div Correction",i
 CALL DIVCORRECTION(AU,AL,IAU,IAL,INU,INL,D,iau_tot,ial_tot,&
      & biccg, istack, item,item_tot, x_vec,nodeg, line, nline,dphi)
 x_vec(:)=x_vec(:)+dphi(:)
end do
write(*,*) "GEGEGE not converged!"

100 continue
write(*,*) "## CONVERGED!! ## FINAL RESID=",RESID

200 continue
allocate(bsedge(nline))
bsedge=x_vec
deallocate(x_vec)
!#[8]## OUTPUT the solution
!#[8-1]## for MT
!CALL CALIMPEDANCE(nline, nodeg, ntetg, n6line, n4g, xyzg, x_vec, omega,pi,dmu)
!#[8-2]## for ACTIVE
CALL OUTSOL(bpedge,bsedge,line,nline,xyzg,nodeg,n4g,n6line,ntetg,outfile,meshfile)

end program n_ebfem
!
!########################################
subroutine GETBANDWIDTH(MB,n6line,ntetg,nline)
implicit none
integer(4),intent(in) :: n6line(ntetg,4),ntetg,nline
integer(4),intent(out) :: MB ! bandwidth
integer(4) :: i,j,k,ibase,iline
MB=0
do i=1,ntetg
 do j=1,5
  ibase=abs(n6line(i,j))
  do k=j+1,6
   iline=abs(n6line(i,k))
   MB=max(MB,(iline-ibase+1))
   MB=max(MB,-(iline-ibase)+1)
  end do
 end do
end do

write(*,*) "BANDWIDTH=",MB,"nline=",nline

return
end
!########################################  DIVCORRECTION
subroutine DIVCORRECTION(AU,AL,IAU,IAL,INU,INL,D,iau_tot,ial_tot,&
      & biccg, istack, item,item_tot, x_vec,nodeg, line, nline,dphi)
implicit none
integer(4),intent(in) :: nline, nodeg, line(2,nline)
!### Matrix and vectors for CG
integer(4),intent(in) :: iau_tot, ial_tot, INU(0:nodeg), INL(0:nodeg)
integer(4),intent(in) :: IAU(iau_tot), IAL(ial_tot)
complex(8),intent(in) :: AU(iau_tot), AL(ial_tot), D(nodeg)
complex(8),intent(out) :: dphi(nline)
!### Matrix to generate b_vec2
complex(8),intent(in) :: x_vec(nline)
integer(4),intent(in) :: item_tot,item(item_tot), istack(0:nodeg)
real(8),intent(in)    :: biccg(item_tot)
!### Parameters for CG
complex(8)    :: b_vec2(nodeg), phi(nodeg)
character(20) :: PRECOND
integer(4) :: doftot, iter, error, nset, i, j
real(8) :: resid, sigma_diag, sigma
!###
integer(4) :: is,ie, inod

!#[1]## calculate b_vec2
        b_vec2(:)=(0.d0,0.d0)
	  do j= 1, nodeg !  j is row id, where NP is intnodtot
	   is= istack(j-1) + 1
	   ie= istack(j  )
	   do i= is, ie
	    inod= item(i) ! colmun id of AU
	    b_vec2(j)= b_vec2(j) + biccg(i)*x_vec(inod)
	   enddo
	  enddo
	 open(1,file="b_vec2.dat")
       write(1,'(4g15.7)') (b_vec2(i),x_vec(i),i=1,nline)
	 close(1)

!#[2]## solve matrix and get phi
doftot=nodeg
PRECOND="SSOR"
RESID=1.e-15      ! convergence tol.
SIGMA_DIAG=1.0    ! diag. mul.
SIGMA=0.0         ! non-diag. mul.
ERROR=0           ! error id (inout)
nset=1            ! precondition 0: no, 1: yes, 2: scaling
ITER=2000
CALL  CG13_single_cpx  (doftot,  ial_tot, iau_tot,    &
     &                  D,  AL, INL, IAL, AU, INU, IAU,  &
     &                  b_vec2,  phi, precond, sigma_diag, sigma, &
     &                  resid,  iter, error,  NSET)

!#[3]## calculate dphi
do i=1,nline
 dphi(i)=phi(line(2,i)) - phi(line(1,i)) ! grad phi * length
end do

write(*,*) "### DIVCORRECTION END!! ###"
return
end
!########################################  OUTSOL
!# Coded on Nov. 21, 2015
!# This calculates the output b fields and output results
subroutine OUTSOL(bpedge,bsedge,line,nline,xyzg,nodeg,n4g,n6line,ntetg,outfile,meshfile)
implicit none
character(50),intent(in) :: outfile,meshfile
character(50) :: bpedgereal="bpedge_real2.msh"
character(50) :: bsedgereal="bsedge_real.msh"
character(50) :: bsedgeimag="bsedge_imag.msh"
integer(4),intent(in) :: nline,line(2,nline),n6line(ntetg,6),nodeg,n4g(ntetg,5),ntetg
real(8),   intent(in) :: xyzg(3,nodeg), bpedge(nline)
complex(8),intent(in) :: bsedge(nline)
complex(8) :: btotal(nline)
real(8) :: dx=0.005d0 ! [km]
real(8) :: xmin=-1.d0, xmax=1.d0 ! [km]
real(8) :: x, x3(3),amp,phase,w(6,3)
complex(8) :: b3t(3), b3s(3),unit=(1.d0,0.d0)
real(8),parameter :: pi=4.d0*datan(1.d0), r2d=180.d0/pi
integer(4) :: i,j,k,n, iele
!#[1]## generate btotal
btotal(1:nline)=bsedge(1:nline)+bpedge(1:nline) ! [nT*km]
!btotal(1:nline)=bsedge(1:nline) ! [nT*km]
open(1,file="out.dat")
do i=1,nline
 write(1,*) bpedge(i),bsedge(i)
end do
close(1)

!#[2]## out bsedge.msh
CALL OUTELEMVEC(bpedgereal,meshfile,bpedge*unit,nline,ntetg,xyzg,nodeg,n4g,n6line,1)! 1 for real
CALL OUTELEMVEC(bsedgereal,meshfile,bsedge,nline,ntetg,xyzg,nodeg,n4g,n6line,1)! 1 for real
CALL OUTELEMVEC(bsedgeimag,meshfile,bsedge,nline,ntetg,xyzg,nodeg,n4g,n6line,2)! 2 for imag


!#[3]## cal b3 comp and output
x3(1:3)=0.d0 ! [km]
x=xmin-dx
open(1,file=outfile)
do while ( x .le. xmax)
 x=x+dx
 x3(1:3)=(/x, 0.03d0, 0.d0/)
 CALL FINDELEMENT(x3, n4g, ntetg, xyzg, nodeg, iele)
 CALL B3COMPONENT(btotal,n6line,nline,xyzg,nodeg,ntetg,n4g,iele,x3,b3t,w)
 CALL B3COMPONENT(bsedge,n6line,nline,xyzg,nodeg,ntetg,n4g,iele,x3,b3s,w)
 amp=dsqrt(dreal(b3s(3))**2.d0 + dimag(b3s(3))**2.d0) ! amp of bz
 phase=datan2(dimag(b3s(3)),dreal(b3s(3)))*r2d ! phase of bz
 write(1,'(5g15.7)') x,b3s(3),amp,phase
end do
close(1)

write(*,*) "### OUTSOL END!! ###"
return
end
!######################################## OUTELEMENTVECTOR
!# coded on Nov. 27, 2015
!# iflag=1 : real, 2: imag
subroutine OUTELEMVEC(filename,meshfile,bedge,nline,ntetg,xyzg,nodeg,n4g,n6line,iflag)
implicit none
character(50),intent(in) :: filename,meshfile
integer(4),intent(in) :: iflag,nodeg,nline,ntetg
integer(4),intent(in) :: n4g(ntetg,5),n6line(ntetg,6)
real(8),intent(in) :: xyzg(3,nodeg)
complex(8),intent(in) :: bedge(nline)
integer(4) :: node,ntet,ntri,nlin,npoi,ishift
integer(4) :: i,j,k,lm(6,2),n1,n2, isig
real(8) :: x3(3),amp, len,b1,w(6,3),unit(3,6)
complex(8) :: b3(3), b6(6)
character(150) :: a
!#[0]##
lm(1,1:2)=(/1,2/)
lm(2,1:2)=(/2,3/)
lm(3,1:2)=(/1,3/)
lm(4,1:2)=(/1,4/)
lm(5,1:2)=(/2,4/)
lm(6,1:2)=(/3,4/)

!#[1]## check iflag
if (iflag .ne. 1 .and. iflag .ne. 2 )then
 write(*,*) "GEGEGE! iflag should be 1 (real) or 2(imag), iflag=",iflag
 stop
end if

!#[2]
CALL MSHCOUNT1(meshfile,node,ntet,ntri,nlin,npoi)  ! npoi = 0 makes no problems
!     allocate(xyzg(3,nodeg),n4g(ntetg,5),n3g(ntrig,4),n2g(nling,3),n1g(npoig))

!#[3]## copy meshfile on vectorfile
open(1,file=filename)
open(2,file=meshfile)
do
read(2,'(a)',end=99) a
write(1,'(a)') a(1:len_trim(a))
end do
99 continue
close(2)

!#[2]## OUTPUT
ishift=npoi+nlin+ntri
write(1,'(a)') "$ElementData"
write(1,'(a)') "1"
write(1,'(a)') '"A vector view"'
write(1,'(a)') "1"
write(1,'(a)') "0.0"
write(1,'(a)') "3"
write(1,'(a)') "0"
write(1,'(a)') "3"
write(1,*) ntetg
do i=1,ntetg
 x3(:)=(xyzg(:,n4g(i,2))+xyzg(:,n4g(i,3))+xyzg(:,n4g(i,4))+xyzg(:,n4g(i,5)))/4.d0
 CALL B3COMPONENT(bedge,n6line,nline,xyzg,nodeg,ntetg,n4g,i,x3,b3,w)
 if (iflag .eq. 1 ) then ! real part
  write(1,*) ishift+i, dreal(b3(1)),dreal(b3(2)),dreal(b3(3))
  amp=dsqrt(dreal(b3(1))**2. + dreal(b3(2))**2. + dreal(b3(3))**2. )
 if ( ishift+i .eq. 12200 ) then
   write(*,*) "x3(:)=",x3(1:3)
   write(*,*) "xyzg(1:3,n4g(i,2))=",xyzg(1:3,n4g(i,2))
   write(*,*) "xyzg(1:3,n4g(i,3))=",xyzg(1:3,n4g(i,3))
   write(*,*) "xyzg(1:3,n4g(i,4))=",xyzg(1:3,n4g(i,4))
   write(*,*) "xyzg(1:3,n4g(i,5))=",xyzg(1:3,n4g(i,5))
   write(*,*) "amp=",amp
   write(*,*) "dreal(b3(1:3))=",(dreal(b3(j)),j=1,3)
   do j=1,6
    n1=n4g(i,lm(j,1)+1) ; n2=n4g(i,lm(j,2)+1)
    x3(1:3)=xyzg(1:3,n2) - xyzg(1:3,n1)
    len=dsqrt(x3(1)**2. + x3(2)**2. + x3(3)**2. ) ! [km]
    unit(1:3,j)=x3(1:3)/len ! dimension less
    b1=bedge(abs(n6line(i,j)))*isign(1, n6line(i,j)) ! [nT*km]
   write(*,*) "j=1",j
   write(*,*) "bedge(abs(n6line(i,j)))=",b1,"len=",len,"b1/len=",b1/len
   end do
   do j=1,6
    write(*,*) "j=",j,"w=",w(j,1:3)
   end do
   do j=1,6
    isig=sign(1, n6line(i,j) )
    b1=dreal(bedge(abs(n6line(i,j))))*isig
    write(*,*) "j=",j,"b1*w=",b1*w(j,1:3)
   end do
 end if
 else                    ! imaginary
  write(1,*) ishift+i, dimag(b3(1)),dimag(b3(2)),dimag(b3(3))
 end if
end do
write(1,'(a)') "$EndElementData"
close(1)
write(*,*)"### OUTPUT TO ",filename(1:len_trim(filename))," END! ###"
return
end
!######################################## B3COMPONENT
subroutine B3COMPONENT(bedge,n6line,nline,xyzg,nodeg,ntetg,n4g,iele,x3,b3,w)
use outerinnerproduct
implicit none
integer(4),intent(in) :: nline,n6line(ntetg,6),nodeg,ntetg,n4g(ntetg,5),iele
complex(8),intent(in) :: bedge(nline) ! [nT*m]
real(8),   intent(in) :: x3(3), xyzg(3,nodeg)
complex(8),intent(out):: b3(3)
real(8) :: v(3,4),x12(3),x13(3),x14(3),x24(3),x23(3),w(6,3),a1,a2,a3,a4,a5
integer(4) :: i,n(1:4),isign, kl(6,2),k,l
!# scheme 2
real(8) :: elm_xyz(3,4), gn(3,4), lambda(4)
!#[1]## generate n4(1:4)
 n(1:4)=n4g(iele,2:5)

!#[2]## generate 4 vectors and x12, x13, x14
 do i=1,4
  v(1:3,i)=xyzg(1:3,n(i)) - x3(1:3) ![km]
 end do
 x12(1:3)=xyzg(1:3,n(2)) - xyzg(1:3,n(1)) ! [km]
 x13(1:3)=xyzg(1:3,n(3)) - xyzg(1:3,n(1))
 x14(1:3)=xyzg(1:3,n(4)) - xyzg(1:3,n(1))
 x24(1:3)=xyzg(1:3,n(4)) - xyzg(1:3,n(2))
 x23(1:3)=xyzg(1:3,n(3)) - xyzg(1:3,n(2))

!#[3]## vector interpolation function (scheme 2)
  do i=1,4
   elm_xyz(1:3,i)=xyzg(1:3,n4g(iele, i+1))
  end do
 call volume(x12, x13, x14, a5)
  gn(:,1)=1.d0/6.d0/a5*outer(elm_xyz(:,4)-elm_xyz(:,2), elm_xyz(:,3)-elm_xyz(:,2))![km^-1]
  gn(:,2)=1.d0/6.d0/a5*outer(elm_xyz(:,3)-elm_xyz(:,1), elm_xyz(:,4)-elm_xyz(:,1))
  gn(:,3)=1.d0/6.d0/a5*outer(elm_xyz(:,4)-elm_xyz(:,1), elm_xyz(:,2)-elm_xyz(:,1))
  gn(:,4)=1.d0/6.d0/a5*outer(elm_xyz(:,2)-elm_xyz(:,1), elm_xyz(:,3)-elm_xyz(:,1))
 call volume(x24, x23, -v(:,2), a1) ; lambda(1)=a1/a5
 call volume(x13, x14, -v(:,1), a2) ; lambda(2)=a2/a5
 call volume(x14, x12, -v(:,1), a3) ; lambda(3)=a3/a5
 call volume(x12, x13, -v(:,1), a4) ; lambda(4)=a4/a5
 kl(1,1:2)=(/1,2/)
 kl(2,1:2)=(/2,3/)
 kl(3,1:2)=(/1,3/)
 kl(4,1:2)=(/1,4/)
 kl(5,1:2)=(/2,4/)
 kl(6,1:2)=(/3,4/)
 do i=1,6
  k=kl(i,1) ; l=kl(i,2)
  w(i,1:3)=lambda(k)*gn(1:3,l) - lambda(l)*gn(1:3,k)
 end do

!#[4]##  interpolate b3 at x3
 b3(1:3)=(0.d0,0.d0)
 do i=1,6
  isign=sign(1, n6line(iele,i) )
  b3(1:3)=b3(1:3) + w(i,1:3)*isign*bedge(n6line(iele,i)*isign)
 end do
return
end
!######################################## FINDELEMENT
! This subroutine finds corresponding elements that includes given coord
subroutine FINDELEMENT(x3,n4g,ntetg,xyzg,nodeg,iele)
implicit none
integer(4),intent(in)  :: ntetg,n4g(ntetg,5), nodeg
real(8),intent(in)     :: xyzg(3,nodeg)
real(8),intent(in)     :: x3(3)
integer(4),intent(out) :: iele
integer(4) :: i, j,n(4)
real(8) :: v(3,4), a1,a2,a3,a4, x12(3),x13(3),x14(3),x24(3),x23(3)
do i=1,ntetg
!if ( n4g(i,1) .eq. 1 ) then ! only elements under surface

 !#[1]## generate n(1:4)
  n(1:4)=n4g(i,2:5) ! note that n4(i,1) indicates element group

 !#[2]## generate v(1:4), vector from the observation point
 do j=1,4
  v(1:3,j)=xyzg(1:3,n(j)) - x3(1:3) ! 4 vectors from point in concern
 end do

 !#[3]## calculate 4 volumes
 x12(:)=xyzg(:,n(2)) - xyzg(:,n(1))
 x13(:)=xyzg(:,n(3)) - xyzg(:,n(1))
 x14(:)=xyzg(:,n(4)) - xyzg(:,n(1))
 x24(:)=xyzg(:,n(4)) - xyzg(:,n(2))
 x23(:)=xyzg(:,n(3)) - xyzg(:,n(2))
 call volume(x12,x13,-v(:,1), a4)
 call volume(x14,x12,-v(:,1), a3)
 call volume(x13,x14,-v(:,1), a2)
 call volume(x24,x23,-v(:,2), a1)

 !#[4]## check weather the point is included in i-th element
 if ( a1 .ge. 0.d0 .and. a2 .ge. 0.d0 .and. a3 .ge. 0.d0 .and. a4 .ge. 0.d0 ) then
  !#if ( elm_xyz(3,1) .eq. 0.d0 .and. elm_xyz(3,2) .eq. 0.d0 .and. elm_xyz(3,3) .eq. 0.d0 ) then
  goto 100
 end if

end do
goto 999 !
!# the corresponding element was chosen
100 iele=i
return
!
999 continue
write(*,*) "GEGEGE! No corresponding element was wound!"
stop
end
!########################################  CALBPONEDGE
subroutine CALBPONEDGE(bpedge,nline, bp, nodeg, line, xyzg,n6line,n4g,ntetg,meshfile)
implicit none
character(50),intent(in) :: meshfile
integer(4),intent(in) :: nline, nodeg, line(2,nline)
integer(4),intent(in) :: ntetg, n4g(ntetg,5),n6line(ntetg,6)
real(8),intent(in) :: bp(3,nodeg)    ! [nT]
real(8),intent(in) :: xyzg(3,nodeg)  ! [km]
real(8),intent(out) :: bpedge(nline)
integer(4) :: i, n1, n2
real(8) :: vec(3), bp1,bp2, veclen
complex(8) :: unit=(1.d0,0.d0)
character(50) :: bpedgereal="bpedge_real.msh"
!#[1]## calculate bpedge
do i=1,nline
 n1=line(1,i)
 n2=line(2,i)
 !#[1]# unit vector along the line
 vec(1:3)=xyzg(1:3,n2)-xyzg(1:3,n1) ! [km]
 veclen=dsqrt(vec(1)**2.d0 + vec(2)**2.d0 + vec(3)**2.d0) ! [km]
 vec(1:3)=vec(1:3)/veclen ! unit vector [dimension less]
 !#[2]# component pallarel to the line
 bp1=vec(1)*bp(1,n1)+vec(2)*bp(2,n1)+vec(3)*bp(3,n1) ! [nT] component along vec
 bp2=vec(1)*bp(1,n2)+vec(2)*bp(2,n2)+vec(3)*bp(3,n2) ! [nT] component along vec
 !#[3]# line integral of bp along the i-th line
 bpedge(i)=(bp1 + bp2)/2.d0 * veclen ! [nT*km]
 if ( ( abs(xyzg(3,n1)) .ge. 0.05 .or. abs(xyzg(3,n2)) .ge. 0.05 ) .and. abs(bpedge(i)) .ge. 3.75) then
 write(*,*) "bp(1:3,n1)=",bp(1:3,n1),"xyzg(1:3,n1)=",xyzg(1:3,n1)
 write(*,*) "|bp|=",dsqrt(bp(1,n1)**2.d0 + bp(2,n1)**2.d0 + bp(3,n1)**2.d0)
 write(*,*) "bp(1:3,n2)=",bp(1:3,n2),"xyzg(1:3,n2)=",xyzg(1:3,n2)
 write(*,*) "|bp|=",dsqrt(bp(1,n2)**2.d0 + bp(2,n2)**2.d0 + bp(3,n2)**2.d0)
 write(*,*) "vec(1:3)=",vec(1:3)
 write(*,*) "bp1=",bp1,"bp2=",bp2
 write(*,*) "bpedge(i)=",bpedge(i)
 stop
 end if
end do

!#[2]## OUT bpedge
CALL OUTELEMVEC(bpedgereal,meshfile,bpedge*unit,nline,ntetg,xyzg,nodeg,n4g,n6line,1)! 1 for real

write(*,*) "### CALBPONEDGE END!! ###"
return
end
!########################################  READBPRIMARY
! Coded on Nov. 21, 2015
subroutine READBPRIMARY(bprimaryfile,bp,nodeg)
implicit none
character(50),intent(in) :: bprimaryfile
integer(4),intent(in) :: nodeg
real(8), intent(out) :: bp(3,nodeg)
integer(4) :: i
open(1,file=bprimaryfile)
 do i=1,nodeg
  read(1,*) bp(1,i),bp(2,i),bp(3,i) ! [nT] at each node
 end do
close(1)
write(*,*) "### READBPRIMARY END!! ###"
return
end
!
!########################################  GENBCCSEM
! Coded on October 19, 2015
! THis subroutine set the boundary condition for calculation boundaries
subroutine  GENBCCSEM(zmin, zmax, xout, yout, line, nline, xyzg, nodeg, Avalue_bc,line_bc,&
& IB)
implicit none
real(8),   intent(in)  :: zmin, zmax, xout, yout ! These parameters are from meshpara.f90
integer(4),intent(in)  :: nodeg, nline, line(2,nline)  ! nline is total number of lines in the mesh
real(8),   intent(in)  :: xyzg(3, nodeg)
logical(4),intent(out) :: line_bc(nline)    ! if .true., the dirichlet boundary is set
complex(8),intent(out) :: Avalue_bc(nline)  ! Dirichlet boundary value
integer(4) :: line_group(nline)  ! 1:top, 2:north, 3:west, 4:south, 5:east, 6:bottom
integer(4) :: i, j, ncount, n1, n2
real(8) :: x1, y1, z1, x2, y2, z2, xout1, yout1, zmin1, zmax1
!# For direct solvers
integer(4),intent(out) :: IB ! # of boundary lines

!#[0]## set boudary coordinates
xout1=xout-1.d0; yout1=yout-1.d0; zmin1=zmin+1.d0;  zmax1=zmax-1.d0

!#[1]## Initialize Avalue_bc and line_bc
line_bc(:)=.false.
Avalue_bc(:)=(0.d0, 0.d0)
line_group(:)=0  ! 1:top, 2:north, 3:west, 4:south, 5:east, 6:bottom

!#[2]## Initialize Avalue_bc and line_bc
IB=0
do i=1,nline
     n1=line(1,i) ; n2=line(2,i)
     x1=xyzg(1,n1) ; y1=xyzg(2,n1) ; z1=xyzg(3,n1)
     x2=xyzg(1,n2) ; y2=xyzg(2,n2) ; z2=xyzg(3,n2)
     if         ( x1 .le. -xout1 .and.  x2 .le. -xout1) then
        line_group(i)=3
     else if  (x1 .ge. xout1 .and.  x2 .ge. xout1 ) then
        line_group(i)=5
     else if  ( y1 .le. -yout1 .and. y2 .le. -yout1 )  then
        line_group(i)=4
     else if  ( y1 .ge. yout1 .and. y2 .ge. yout1 ) then
        line_group(i)=2
     else if  ( z1 .le. zmin1 .and. z2 .le. zmin1 )  then
        line_group(i)=6
     else if  ( z1 .ge. zmax1 .and. z2 .ge. zmax1 ) then
	  line_group(i)=1
     end if
     if ( line_group(i) .ne. 0 ) then
	   line_bc(i) = .true.
	   Avalue_bc(i)=(0.d0, 0.d0)
	   IB=IB+1
     end if
end do    ! line loop

!#[3]## Output .msh file to confirm which lines are selected
CALL OUTBCLINES(line_bc, line, nline, xyzg, nodeg,line_group)

write(*,*) "### GENBCCSEM END!! ###"
return
end subroutine
!################################################  OUTBCLINES
! Coded on October 19,
subroutine OUTBCLINES(line_bc, line, nline, xyzg, nodeg, line_group)
implicit none
integer(4),intent(in) :: nline, nodeg, line(2,nline), line_group(nline)
real(8),intent(in) :: xyzg(3, nodeg)
logical, intent(in) :: line_bc(nline)
integer(4) :: i, nline_bc, icount
!#[1]## count the number of boundary lines
nline_bc=0
do i=1,nline
if ( line_bc(i) ) nline_bc=nline_bc+1
end do
write(*,*) "nline_bc=",nline_bc

!#[2]## Output line.msh
open(1,file="bcline.msh")
write(1,'(a)') "$MeshFormat"
write(1,'(a)')  "2.2 0 8"
write(1,'(a)')  "$EndMeshFormat"
write(1,'(a)')  "$Nodes"
write(1,*)  nodeg
do i=1,nodeg
write(1,*) i,xyzg(1:3,i)
end do
write(1,'(a)') "$EndNodes"
write(1,'(a)') "$Elements"
write(1,*)  nline_bc
icount=0
do i=1,nline
  if (line_bc(i)) then
    icount=icount+1
    write(1,*) icount, " 1 2 0", line_group(i), line(1,i), line(2,i)
  end if
end do
write(1,'(a)') "$EndElements"
close(1)
return
end
!
!######################################## CALIMPEDANCE
! Calculate impedance from obtained x_vec (line integral of A at each edge)
subroutine CALIMPEDANCE(nline, nodeg, ntetg, n6line, n4g, xyzg, x_vec, omega, pi, dmu)
implicit none
integer(4),intent(in) :: nline, nodeg, ntetg, n6line(ntetg,6),n4g(ntetg,5)
real(8),intent(in) :: xyzg(3,nodeg), omega, pi, dmu
complex(8),intent(in) :: x_vec(nline)
integer(4) :: i, j, n(4), iele, enod=4, ndim=3, idat
real(8),dimension(3) ::  xyz0, x12,x13,x14,x24,x23
real(8) :: a1, a2, a3, a4, a5, w(6,3), v(3,4), xx(3,6) ! xx : rot w
real(8) :: z3(3), znow, h1, h2
integer(4),parameter :: ndat=4
complex(8) :: E(ndat,3), B(ndat,3), Z, BX0, BX1,BX2,Ey1,Ey2,Ey3
real(8) :: d2r, phase, rho
d2r=pi/180.d0
! cal apparant resistivity and phase at origin
!#[1]## find corresponding
z3=(/100.d0, 99.5d0, 99.0d0/)
do idat=1,3
 znow=z3(idat)
 xyz0(1:3)=(/0.d0, 0.d0, znow/)
 do i=1,ntetg
  !if ( n4g(i,1) .eq. 1 ) then ! only elements under surface
  do j=1,4
   n(j)=n4g(i, j+1)   ! n(j) is the global node id of j-th node
   v(:,j)=xyzg(:,n(j)) - xyz0(:)
  end do
  x12(:)=xyzg(:,n(2)) - xyzg(:,n(1))
  x13(:)=xyzg(:,n(3)) - xyzg(:,n(1))
  x14(:)=xyzg(:,n(4)) - xyzg(:,n(1))
  x24(:)=xyzg(:,n(4)) - xyzg(:,n(2))
  x23(:)=xyzg(:,n(3)) - xyzg(:,n(2))
  call volume(x12,x13,-v(:,1), a4)
  call volume(x14,x12,-v(:,1), a3)
  call volume(x13,x14,-v(:,1), a2)
  call volume(x24,x23,-v(:,2), a1)
  !# find the corresponding element
  if ( a1 .ge. 0.d0 .and. a2 .ge. 0.d0 .and. a3 .ge. 0.d0 .and. a4 .ge. 0.d0 ) then
  !if ( xyzg(3,n(1)) .gt. 99.d0 .and. xyzg(3,n(2)) .gt. 99.d0 .and. xyzg(3,n(3)) .gt. 99.d0 ) then
  !#if ( elm_xyz(3,1) .eq. 0.d0 .and. elm_xyz(3,2) .eq. 0.d0 .and. elm_xyz(3,3) .eq. 0.d0 ) then
   goto 100
  end if !; end if !; end if
 end do
 goto 999
 !# the corresponding element was chosen
 100 iele=i
 !#[2]## CAL Phi and Rho
 ! vector interpolation function
 call outerproduct( v(:,3), v(:,4), w(1,:) )
 call outerproduct( v(:,1), v(:,4), w(2,:) )
 call outerproduct( v(:,4), v(:,2), w(3,:) )
 call outerproduct( v(:,2), v(:,3), w(4,:) )
 call outerproduct( v(:,3), v(:,1), w(5,:) )
 call outerproduct( v(:,1), v(:,2), w(6,:) )
 call volume(x12, x13, x14, a5)
 w(:,:)=w(:,:)/6./a5
 xx(:,1)=xyzg(:, n(4)) - xyzg(:, n(3))
 xx(:,2)=xyzg(:, n(4)) - xyzg(:, n(1))
 xx(:,3)=xyzg(:, n(2)) - xyzg(:, n(4))
 xx(:,4)=xyzg(:, n(3)) - xyzg(:, n(2))
 xx(:,5)=xyzg(:, n(1)) - xyzg(:, n(3))
 xx(:,6)=xyzg(:, n(2)) - xyzg(:, n(1))
 xx(:,:)=xx(:,:)/3./a5
 !#[3]##  E and B at (0, 0, 0)
 E(idat,1:3)=(0.d0,0.d0) ; B(idat, 1:3)=(0.d0,0.d0)
 do i=1,6
  E(idat,:)=E(idat,:) - (0.d0,1.d0)*omega*w(i,:)*sign(1, n6line(iele,i) )*x_vec(abs(n6line(iele,i)))
  B(idat,:)=B(idat,:)                               + xx(:,i)*sign(1, n6line(iele,i) )*x_vec(abs(n6line(iele,i)))
 end do
end do ! idat loop end
!# Phase, Ryx, |Z|=sqrt(omega/mu/sigma) ->
do idat=1,3
Z=E(idat, 2)/B(idat,1)              ! Ey [micro V/m], B(1) [nT]
phase=datan2(dimag(Z),dreal(Z))/d2r
rho=dmu*(10**6.d0)/omega*(Z*conjg(Z)) !
!## output the results
write(*,'(a,3g15.7)') "z3(idat)=", z3(idat)
do i=1,3
  write(*,*) "i=",i,"E(i)=",E(idat, i), "B(i)=",B(idat,i)
end do
write(*,*) "rho=",rho,"[Ohm.m]"
write(*,*) "phase=",phase,"[deg]"
end do
write(*,*) "final result"
h1=z3(1)-z3(2)
h2=z3(2)-z3(3)
Ey1=E(1,2) ; Ey2=E(2,2) ; Ey3=E(3,2)
BX1=-(0.d0,1.d0)/omega*(Ey1-Ey2)/h1
BX2=-(0.d0,1.d0)/omega*(Ey1-Ey3)/(h1+h2)
BX0=(Bx1-Bx2)*h1/h2 + Bx1
write(*,*) "BX0 (z=0)=",BX0
write(*,*) "BX1 (z=z2)=",BX1
write(*,*) "BX2 (z=z3)=",BX2
Z=E(1, 2)/BX0              ! Ey [micro V/m], B(1) [nT]
phase=datan2(dimag(Z),dreal(Z))/d2r
rho=dmu*(10**6.d0)/omega*(Z*conjg(Z))
write(*,*) "rho=",rho,"[Ohm.m]"
write(*,*) "phase=",phase,"[deg]"
write(*,*) "### CALIMPEDANCE END!! ###"
return
999 continue
write(*,*) "GEGEGE! No corresponding element was wound!"
stop
end
!######################################## genfacebase
subroutine genfacebase(n_e, dn_dx, lmn, wf )
implicit none
integer(4),intent(in) :: lmn(3)
real(8),intent(in) :: n_e(4), dn_dx(3,4)
real(8),intent(out) :: wf(3)
real(8),dimension(3) :: v1, v2, v3
integer(4) :: l,m,n
l=lmn(1) ; m=lmn(2) ; n=lmn(3)
call outerproduct(dn_dx(1:3,l), dn_dx(1:3,m),v1)
call outerproduct(dn_dx(1:3,m), dn_dx(1:3,n),v2)
call outerproduct(dn_dx(1:3,n), dn_dx(1:3,l),v3)
wf(1:3)=2.d0*(n_e(l)*v2(1:3)+n_e(m)*v3(1:3)+n_e(n)*v1(1:3))
return
end
subroutine outerproduct(v1,v2,v3)
implicit none
real(8),intent(in) :: v1(3),v2(3)
real(8),intent(out) :: v3(3)
v3(1)=v1(2)*v2(3) - v1(3)*v2(2)
v3(2)=v1(3)*v2(1) - v1(1)*v2(3)
v3(3)=v1(1)*v2(2) - v1(2)*v2(1)
return
end
!######################################## GENBCMT
! Coded on Aug. 25, 2015
! subroutine to fine lines where boundary condition will be forced
subroutine GENBCMT(line, nline, xyzg, nodeg, n6line, ntetg, omega,  line_bc, Avalue_bc)
implicit none
integer(4),intent(in) :: nline, line(2,nline),  nodeg, n6line(ntetg,6), ntetg
real(8), intent(in) :: xyzg(3, nodeg), omega
logical,intent(out) :: line_bc(nline)
complex(8),intent(out) :: Avalue_bc(nline)
integer(4) :: n1, n2, n3, n4, n5, i,j,k, iele
real(8) :: ztop, xyzvec(3), ey
integer(4) :: line2elem(nline, 13), nline_elem(nline)
complex(8) :: A(3)
ey=1.d0
A(1)=(0.d0, 0.d0)
A(2)=ey/(-(0.d0,1.d0)*omega) ! i*ey*omega
A(3)=(0.d0,0.d0)
!#[1]## generate line2elem, and nline_elem
nline_elem(:)=0 ; line2elem(:, :)=0
write(*,*) "line2elem, and nline_elem generation start!"
do i=1,ntetg
do j=1,6
  n1=abs(n6line(i,j))
  nline_elem(n1)=nline_elem(n1)+1
  line2elem(n1,nline_elem(n1) ) = i ! element id
end do
end do
write(*,*) "nline_elem and line2elem is generated!!"
!#[2]## set A value to Avalue_bc at elements near surface
ztop=xyzg(3,1) ! here we assume the first node is in the top surface
line_bc(:) = .false.
do i=1,nline
write(*,*) "i=",i,"nline=",nline
n1=line(1,i)
n2=line(2,i)
if (xyzg(3,n1) .eq. ztop .and. xyzg(3, n2) .eq. ztop ) then ! if line included in surface
!do j=1, nline_elem(i) ! element loop for i-th line
!iele=line2elem(i,j) ! j-th element of i-th line
!  do k=1,6 ! line loop for j-th element
!  n3=abs(n6line(iele,k)) ! n3 is line id
!  if ( .not. line_bc(n3) ) then ! if the boundary condition is not set
    n3=i
    line_bc(n3)=.true.
    n4=line(1,n3)
    n5=line(2,n3)
    xyzvec(1:3)=xyzg(1:3,n5) - xyzg(1:3,n4)
    ! (Axy(2)*xvec(2)/dlength) * dlength
    Avalue_bc(n3)=A(1)*xyzvec(1) + A(2)*xyzvec(2) +  A(3)*xyzvec(3)! the value should be line integral
    write(*,*) "n3=",n3,"Avalue_bc(n3)=", Avalue_bc(n3)
    write(*,*) "xyzg(1:3,n4)=",xyzg(1:3,n4)
    write(*,*) "xyzg(1:3,n5)=",xyzg(1:3,n5)
    write(*,*) "===================="
  end if
!  end do ! line loop for j-th element
!end do   ! element loop for i-th line
!end if
end do
write(*,*) "### GENBCMT END! ###"
return
end subroutine GENBCMT
!######################################## GENMAT8
! Modified on Nov. 21, 2015
! replace integration by tetrai_table by analytical integration
subroutine GENMAT(ntetg, n6line, xyz, n4, nodeg, omega, nline,pi,dmu,bpedge,bp,AMB,MB)
use  outerinnerproduct
use  iccg_var_takuto ! b_vec is included
implicit none
integer(4),intent(in) :: ntetg, n6line(ntetg,6), n4(ntetg,5), nodeg, nline
real(8),   intent(in) :: xyz(3, nodeg), omega, pi, dmu
real(8),   intent(in) :: bpedge(nline),bp(3,nodeg) ! [nT*km]
real(8)    :: elm_xyz(3,4)! nodal coordinates of element elm_xyz(i,j) i:x,y,z,j-th node
real(8)    :: xx(3,6), w(6,3), S(6,6), ww(6,6), v, sigma, yy, gn(3,4),b3(3)
complex(8) :: elm_k(6,6), S1(6,6)
complex(8) :: iunit=(0.d0, 1.d0), unit=(1.d0,1.d0)
integer(4) :: table_dof_elm(6), lm(6,2)
integer(4) :: iele, i, j, k, l, m, n, ii, jj, idirection(6)
!# for direct solver
integer(4),intent(in) :: MB
complex(8),intent(out) :: AMB(MB,nline)
integer(4) :: IC,ID, ischeme
!#
real(8)    :: intv ! n_e, dn_dx for natural coord
!---------------  scales ------------------------------------------------------
real(8), parameter  :: L0=1.d+3  ! [m]  scale length
real(8)    :: AA
complex(8) :: BB
do iele=1, ntetg  ! start elemetn loop
!#
  !# [1] ## ! check the direction of edge, compared to the defined lines
  idirection(1:6)=1
  do j=1,6
    if ( n6line(iele, j) .lt. 0 ) idirection(j)=-1
  end do

  !# [2] ## Prepare the coordinates for 4 nodes of elements
  elm_xyz(1:3,1)=xyz(1:3,n4(iele,2)) ! [km]
  elm_xyz(1:3,2)=xyz(1:3,n4(iele,3))
  elm_xyz(1:3,3)=xyz(1:3,n4(iele,4))
  elm_xyz(1:3,4)=xyz(1:3,n4(iele,5))

  !# [3] ## First term from the rot rot, S
  ! 1/L^2/mu*int{ (rot w) cdot (rot Bs) }dv =1/L^2/mu*int{(rot w)cdot(rot w)}dv {bsl}
  ! here, rot w =1/3/v*x_mn, then (rot w) cdot (rot w)=1/9/v^2*(x_mn cdot x_m'n')
  ! Finally, 1/L^2/mu*int{ (rot w) cdot (rot Bs) }dv
  ! =        1/L^2/mu/9/v*(x_mn cdot x_m'n')
  ! [x_lm]^T=L{x'34 x'14 x'42 x'23 x'31 x'12}=L[x'_lm]^T
  !  where L = scale length, L=1000 m =1.0 km, in the following
  xx(:,1)=elm_xyz(:, 4) - elm_xyz(:, 3) ! [km]
  xx(:,2)=elm_xyz(:, 4) - elm_xyz(:, 1)
  xx(:,3)=elm_xyz(:, 2) - elm_xyz(:, 4)
  xx(:,4)=elm_xyz(:, 3) - elm_xyz(:, 2)
  xx(:,5)=elm_xyz(:, 1) - elm_xyz(:, 3)
  xx(:,6)=elm_xyz(:, 2) - elm_xyz(:, 1)
  call volume(xx(:,1), xx(:,5), -xx(:,4), V) ! volume of this element [km^3]
  if ( v .le. 0 ) goto 999
  AA=1.d0/9.d0/dmu/v/L0**2.d0
  ![m^2*rad/s*S/m]*[km^-3]/1.d6=[km^-1*rad/s*S/m], because 1/mu [m^2*rad/s*S/m]
  S(:,:)=(0.d0, 0.d0)
  do j=1,6
    do k=1,6
	S(j,k)=inner(xx(1:3,j),xx(1:3,k))*idirection(j)*idirection(k)*AA  ! S is real
    end do
  end do   ! S [km*rad/s*S/m]

  !# [4] ## Second term from i * omega* sigma* int{ sigma w cdot (A) dv
  ! assemble coefficient for i * omega* int{ sigma w cdot (A) dv 
  !                       =  i * omega* sigma* int [w] cdot [w] dv {Al}
  if ( n4(iele,1) .eq. 1 ) sigma=0.d0   !+ (0.d0, 1.d0)*omega*8.854*1.d-12! air
  if ( n4(iele,1) .eq. 2 ) sigma=1.d0 ! crust and mantle
  if ( n4(iele,1) .eq. 3 ) sigma=0.2d0   ! ocean
  if ( n4(iele,1) .eq. 4 ) sigma=0.01d0   ! ocean
  BB=iunit*omega*sigma   ! BB is complex in ww, dn_dx twice

  !# [4-1] ## assemble scheme No.1 ( numerical integration ) is deleted on Nov. 22, 2015
  !# [4-2] ## assemble scheme No.2 ( analytical assembly)
  ! Since \nabla lambda_k =1/6/V*( x_ln \times x_lm )  is constant,
  ! int { w_i cdot w_j }dv can be calculated analytically
  S1(:,:)=(0.d0,0.d0)
  lm(1,1:2)=(/1,2/)
  lm(2,1:2)=(/2,3/)
  lm(3,1:2)=(/1,3/)
  lm(4,1:2)=(/1,4/)
  lm(5,1:2)=(/2,4/)
  lm(6,1:2)=(/3,4/)
  ! gradient of nodal shape function, where outer vector, gn(:,i), points to i-th node
  gn(:,1)=1.d0/6.d0/v*outer(elm_xyz(:,4)-elm_xyz(:,2), elm_xyz(:,3)-elm_xyz(:,2))![km^-1]
  gn(:,2)=1.d0/6.d0/v*outer(elm_xyz(:,3)-elm_xyz(:,1), elm_xyz(:,4)-elm_xyz(:,1))
  gn(:,3)=1.d0/6.d0/v*outer(elm_xyz(:,4)-elm_xyz(:,1), elm_xyz(:,2)-elm_xyz(:,1))
  gn(:,4)=1.d0/6.d0/v*outer(elm_xyz(:,2)-elm_xyz(:,1), elm_xyz(:,3)-elm_xyz(:,1))
  ! yy = int { w_i cdot w_j }dv, where w is vector shape function
  !      = int [n_k*gn(:,l) - n_l*gn(:,k) ] cdot [n_m*gn(:,n) - n_n*gn(:,m) ] dv
  !      = int ( n_k*n_m ) dv [ gn(:,l) cdot gn (:,n) ]      first
  !       - int ( n_k*n_n ) dv [ gn(:,l) cdot gn (:,m) ]       second
  !      -  int ( n_l*n_m ) dv [ gn(:,k) cdot gn (:,n) ]       third
  !       + int ( n_l*n_n ) dv [ gn(:,k) cdot gn (:,m) ]      forth
  do i=1,6
    do j=1,6
      k=lm(i,1) ; l=lm(i,2) ; m=lm(j,1) ; n=lm(j,2) ! gn*gn [km^-2], intv [km^3], yy[km]
      yy =     intv(k,m,v)*inner(gn(:,l), gn(:,n))   & ! first term
     &	-  intv(k,n,v)*inner(gn(:,l), gn(:,m))   & ! second term
     &      -  intv(l,m,v)*inner(gn(:,k), gn(:,n))   & ! third term
     &      +  intv(l,n,v)*inner(gn(:,k), gn(:,m))     ! forth term
     S1(i,j)= unit*yy*idirection(i)*idirection(j) ! S1 [km*rad/s*S/m]
    end do
  end do
  S1=S1*BB ! S2 (complex)

  !# [5] ## Construct elemnt matrix, elm_k
  elm_k(:,:)=S(:,:)+S1(:,:) ! elm_k (complex), S(real), S2(complex)
  !if ( n4(iele,1) .eq. 1) then
  !CALL checkvalues(elm_xyz,xx,gn,elm_k,S,6,S1,6,6,v)
  !stop
  !end if

  !# [6] ## Set global matrix from elm_k
  do i=1,6
     table_dof_elm(i)=n6line(iele,i)*idirection(i) ! make n6line positive
  end do
  CALL sup_iccg(elm_k,table_dof_elm,6,diag,istack_u,item_u,aiccg_u,nline,item_u_tot)

  !# [6.5] ## set AMB
  do i=1,6
   IC=n6line(iele,i)*idirection(i)
   do j=1,6
    ID=n6line(iele,j)*idirection(j) - IC + 1
    if (ID .ge. 1 ) AMB(ID,IC)=AMB(ID,IC)+elm_k(i,j)
   end do
  end do

  !# [7] ## set right hand side vector, b_vec
  !# scheme 1 (use bpedge)
  ischeme=2
  if ( ischeme .eq. 1 ) then
  do i=1,6
   ii=n6line(iele,i)*idirection(i)
   do j=1,6
    jj=n6line(iele,j)*idirection(j)
    b_vec(ii)=b_vec(ii) - S1(i,j)*bpedge(jj) ! - is necessary, b_vec [nT*km]
   end do
  end do
  !# scheme 2 (use bp at center of gravity)
  else
   do j=1,6
    b3(1:3)=(bp(:,n4(iele,2))+bp(:,n4(iele,3))+bp(:,n4(iele,4))+bp(:,n4(iele,5)))/4.d0
    k=lm(j,1) ; l=lm(j,2)
    jj=n6line(iele,j)*idirection(j)
    b_vec(jj)=b_vec(jj) - BB*intv(k,l,v)*inner(gn(:,l)-gn(:,k),b3(:))! - is necessary, b_vec [nT*km]
   end do
  end if
end do ! element loop end
write(*,*) "### GENMAT END !! ###"
return
999 continue
write(*,*) "GEGEGE! volume is less than 0; iele=",iele
write(*,*)  "xx(:,1)=",xx(:,1)
write(*,*)  "xx(:,5)=", xx(:,5)
write(*,*)  "-xx(:,4)=",-xx(:,4)
stop
end subroutine GENMAT
!################################################### checkvalues
subroutine checkvalues(elm_xyz,xx,gn,elm_k,S,dof1,S1,dof2,dof3,v)
implicit none
integer(4),intent(in) :: dof1,dof2,dof3
real(8),intent(in) :: v
real(8),intent(in) :: elm_xyz(3,4)
real(8),intent(in) :: xx(3,6)
real(8),intent(in) :: gn(3,4)
real(8),intent(in)    ::     S(dof1,dof1)
complex(8),intent(in) :: elm_k(dof1,dof1)
complex(8),intent(in) ::    S1(dof2,dof3)
integer(4) :: i,j,k
! elm_xyz(3,4)
write(*,*) "elm_xyz="
write(*,'(3g15.7)') ((elm_xyz(i,j),i=1,3),j=1,4)
! xx(3,6)
write(*,*)"xx"
write(*,'(3g15.7)') ((xx(i,j),i=1,3),j=1,6)
write(*,*) "volume=",v
! gn(3,4) (real)
write(*,*) "gn"
write(*,'(3g15.7)')((gn(i,j),i=1,3),j=1,4)
! S(4,4) (real)
write(*,*) "S"
do j=1,dof1
 write(*,*) (S(j,k),k=1,dof1)
end do
! elm_k(4,4) (complex)
write(*,*) "elm_k"
do j=1,dof1
 write(*,*) (elm_k(j,k),k=1,dof1)
end do
! S1 (complex)
write(*,*) "S1"
do i=1,dof2
 write(*,*) (S1(i,j),j=1,dof3)
end do
stop
end
!#############################################
! integral of shape function
function intv(k, m, v)
implicit none
integer(4),intent(in) :: k, m
real(8),intent(in) :: v ![km^3]
real(8) :: intv
! here assume k = l
! intv =6v*(k!l!m!n!)/(k+l+m+n+3)!
if ( k .ne. m ) intv=v/20.d0 ![km^3]
if ( k .eq. m ) intv=v/10.d0 ![km^3]
return
end function intv
!#############################################
! assume closs produxt of x1 and x2 point on the side of direction of x3
! volume can be minus when (x1 times x2) cdot x3 < 0
subroutine volume(x1, x2, x3, v)
use outerinnerproduct
implicit none
real(8),dimension(3),intent(in) ::x1,x2,x3
real(8),intent(out) :: v
real(8),dimension(3) :: x12
v=1.d0/6.d0*inner(outer(x1,x2), x3)
return
end subroutine volume
!#############################################  mul_atb
subroutine  mul_atb( a, b, c,  aj_leng, bi_leng, cj_leng  )
!    multiply matrix 'c' = 'a't * 'b'
!      c(aj_leng,cj_leng) = a(bi_leng,aj_leng) * b(bi_leng,cj_leng)
implicit    none
integer(4) ,  intent(in)  ::  aj_leng !  2-nd element length of array 'a'
integer(4) , intent(in)  ::  bi_leng  ! 1-st element length of array 'b'
integer(4) , intent(in)  ::  cj_leng  !  2-nd element length of array 'c'
real (8), dimension(bi_leng, aj_leng), intent(in)  ::  a! input matrix 'a'
real (8), dimension(bi_leng, cj_leng), intent(in)  ::  b !   input matrix 'b'
real (8), dimension(aj_leng, cj_leng), intent(out) ::  c   !  input matrix 'c'
integer(4 )  ::  i, j, k
do i=1,aj_leng
  do j=1,cj_leng
    c(i,j) = 0.d0
  do k=1,bi_leng
  c(i,j) = c(i,j) + a(k,i)*b(k,j)
enddo
enddo
enddo
return
end subroutine  mul_atb!
!######################################## MKN6LINE
! make n6line, which store 6 lines composing tetrahedron, including direction info
! Coded on 2015.08.15 by T. MINAMI
subroutine MKN6(ntetg, n4g, n6line, nodeg, line_stack,  nline, line_item)
implicit none
integer(4),intent(in) :: ntetg, n4g(ntetg, 5), nodeg, line_stack(0:nodeg), nline, line_item(nline)
integer(4),intent(out) :: n6line(ntetg, 6)
integer(4),dimension(6,2) :: n2
integer(4) :: i,j,k, icount, lineid,idirection, n11,n12
n2(1,1:2)=(/1,2/)
n2(2,1:2)=(/2,3/)
n2(3,1:2)=(/1,3/)
n2(4,1:2)=(/1,4/)
n2(5,1:2)=(/2,4/)
n2(6,1:2)=(/3,4/)
do i=1,ntetg
do j=1,6
n11=n4g(i, n2(j,1)+1) ; n12=n4g(i, n2(j,2)+1) ; idirection=1
if ( n11 .gt. n12 ) then
n12=n4g(i, n2(j,1)+1) ; n11=n4g(i, n2(j,2)+1) ; idirection=-1
end if
icount=line_stack(n11-1)
do k=line_stack(n11-1)+1, line_stack(n11)
icount=icount+1
if ( line_item(k) .eq. n12 ) goto 100
end do
goto 99
100 continue
lineid=icount
n6line(i,j)=idirection*lineid
end do
!write(*,*) "i=",i,"ntetg=",ntetg,"n6line(i,1:6)=",n6line(i,1:6)
end do
write(*,*) "### MKN6LINE END!! ###"
return
99 write(*,*) "GEGEGE! i=",i,"/ntetg=",ntetg," line n11, n12=",n11,n12, "was not found!"
stop
end subroutine MKN6
!######################################## SETLINE
subroutine SETLINE( line, line_item, nline, line_item_work, maxnline,&
                  & line_stack, nodeg)
implicit none
integer(4),intent(in) :: nline, nodeg, line_stack(0:nodeg), maxnline, line_item_work(maxnline)
integer(4),intent(out) :: line(2,nline), line_item(nline)
integer(4) :: i, j, icount
icount=0
do i=1,nodeg
  do j=line_stack(i-1)+1, line_stack(i)
    line_item(j)=line_item_work(j)
    icount=icount+1
    line(1:2,icount)=(/ i,line_item(j) /)
    !write(*,*) "icount=",icount, "line(1:2,icount)=",line(1:2,icount)
  end do
end do
if ( icount .ne. nline ) goto 99
write(*,*) "### SETLINE END ###"
return
99 write(*,*) "GEGEGE! icount=", icount,"is not equal to nline=",nline
stop
end subroutine SETLINE
!######################################## MKLINE
! line_stack(i) - line_stack(i-1) corresponds to the number of lines belonging to i-th node
! line_item(j) is the ending node id of j-th line
! NOTE that the line ids are ordered by the starting nodes.
! nline is total number of edge lines, including the edges corresponding to the source cable
subroutine MKLINE(line_stack, line_item, maxnline, nline, nodeg, ntetg, n4)
implicit none
integer(4),intent(in) :: maxnline, nodeg, ntetg, n4(ntetg,5)
integer(4),intent(out) :: line_stack(0:nodeg), line_item(maxnline), nline
integer(4) :: i,j,k,l,n1,n2
line_stack(0:nodeg)=0 ; nline=0
do i=1,ntetg ! element loop
  do j=2,5      ! element node loop for starting node
    n1=n4(i,j)
    do k=2,5   ! element node loop for end node
      n2=n4(i,k)
      if ( n1 .lt. n2) then    ! deal only with the case that start node id, n1, is less than end node, n2
      do l=line_stack(n1-1)+1, line_stack(n1)
        if ( n2 .eq. line_item(l) ) goto 100  !    check whether the line (n1, n2) exist or not
      end do
      line_item(line_stack(n1)+2:nline+1)=line_item(line_stack(n1)+1:nline)
      line_stack(n1:nodeg)=line_stack(n1:nodeg)+1
      if ( nline .eq. maxnline ) goto 999
        line_item( line_stack(n1) ) = n2
        nline=nline+1
        100 continue
      end if
    end do
  end do
end do
write(*,*) "nline=",nline
do i=1,nodeg
!write(*,*) "i=",i,"line_stack(i)=",line_stack(i),"line_item(i)=",(line_item(j),j=line_stack(i-1)+1,line_stack(i))
end do
write(*,*) "### MKLINE END ###"
return
999 continue
write(*,*) "GEGEGE! # of line exceeds maxnline =", maxnline
write(*,*) "ntetg=",ntetg,"i=",i
stop
end subroutine MKLINE
!########################################### mshcount1
subroutine mshcount1(mshfile,node,ntet,ntri,nlin,npoi)
implicit none
integer(4),intent(out) :: node,ntet,ntri,nlin,npoi
integer(4) :: i,j,k,itype,ii,jj,kk,etype,nele,n44(4)
character(50),intent(in) :: mshfile
open(1,file=mshfile)
do i=1,4
read(1,*)
end do
read(1,*) node
!write(*,*) "node=",node
do i=1,node+2 ! include "$EndNodes", "$Elements" lines
read(1,*)
end do
read(1,*) nele ! total number of elements
npoi=0;nlin=0;ntri=0;ntet=0
do i=1,nele
read(1,*) j,itype,ii,jj,kk,(n44(k),k=1,etype(itype))
if ( itype .eq. 15) then   ! Point element
npoi=npoi+1
else if ( itype .eq. 1) then ! Line element
nlin=nlin+1
else if ( itype .eq. 2) then   ! Triangle element
ntri=ntri+1
else if ( itype .eq. 4) then ! Tetrahedral element
ntet=ntet+1
end if
end do
close(1)
!write(*,*) "# of Point elements is",npoi
!write(*,*) "# of Line elements is",nlin
!write(*,*) "# of Triangle elements is",ntri
!write(*,*) "# of Tetrahedron elements is",ntet
write(*,*) "### COUNT ", mshfile(1:len_trim(mshfile))," END!! ###"
return
end subroutine mshcount1
!##########################################  readocean1
subroutine readmsh2(mshfile,xyz,node,n4,n3,n2,n1,ntet,ntri,nkk,nlin,npoi)
implicit none
integer(4),intent(in) :: node,ntet,ntri,nlin,npoi
real(8),dimension(3,node),intent(out) :: xyz
integer(4),intent(out) :: n4(ntet,5),n3(ntri,4),n2(nlin,3),n1(npoi)
integer(4) :: itet,itri,ilin,ipoi,nele,inode
integer(4) :: i,j,k,ii,jj,kk,itype,etype,nkk
character(50) :: mshfile
integer(4),dimension(4) :: n44
open(1,file=mshfile)
!# [1] ### skip header
do i=1,4
read(1,*)
end do
!# [2] ### read node
read(1,*) inode
write(*,*) "# of nodes (node) =",inode
if ( inode .gt. node) goto 999
do i=1,node
read(1,*) j,(xyz(k,i),k=1,3)
end do
read(1,*)
!# [3] ### read elements
read(1,*) ! skip the starting line, "$Elements"
read(1,*) nele
write(*,*)"# of elements (nele)=",nele
ipoi=0;ilin=0;itri=0;itet=0;nkk=0
do i=1,nele
read(1,*) j,itype,ii,jj,kk,(n44(k),k=1,etype(itype))
if ( itype .eq. 15) then   ! Point element
ipoi=ipoi+1
n1(ipoi)=n44(1)
else if ( itype .eq. 1) then ! Line element
ilin=ilin+1
n2(ilin,1)=kk !  line # defined in .geo file
n2(ilin,2:3)=n44(1:2)
else if ( itype .eq. 2 ) then ! Triangle element
itri=itri+1
n3(itri,1)=kk !
n3(itri,2:4)=n44(1:3)
if (kk .eq. 1) nkk=nkk+1 ! count triangle group 1
else if ( itype .eq. 4) then ! Tetrahedral element
itet=itet+1
n4(itet,1)=kk
n4(itet,2:5)=n44(1:4)
end if
end do
write(*,*) "# of Point elements is",npoi
write(*,*) "# of Line elements is",nlin
write(*,*) "# of Triangle elements is",ntri
write(*,*) " # of traiangle group1 is",nkk
write(*,*) "# of Tetrahedron elements is",ntet
close(1)
write(*,*) "### READ ", mshfile(1:len_trim(mshfile))," END!! ###"
return
999 write(*,*) "GEGEGE node .ne. inode, node=",node,"inode=",inode
stop
end subroutine readmsh2
!###########################################  function etype
function etype(itype)
implicit none
integer(4) :: itype,etype
etype=0
if (itype .eq. 15) etype=1! one point node
if (itype .eq. 1 ) etype=2 ! line
if (itype .eq. 2 ) etype=3 ! triangle
if (itype .eq. 4 ) etype=4 ! tetrahedron
return
end function
!###############################################  mul_ab
subroutine  mul_ab ( a, b, c,  ai_leng, bi_leng, cj_leng  )
!    multiply matrix 'c' = 'a' * 'b'
!      c(ai_leng,cj_leng) = a(ai_leng,bi_leng) * b(bi_leng,cj_leng)
implicit    none
integer(4), intent(in)  ::  ai_leng ! 1-st element length of array 'a'
integer(4), intent(in)  ::  bi_leng ! 1-st element length of array 'b'
integer(4), intent(in)  ::  cj_leng !  2-nd element length of array 'c'
real (8), dimension(ai_leng, bi_leng), intent(in)  ::  a !   input matrix 'a'
real (8), dimension(bi_leng, cj_leng), intent(in)  ::  b  !  input matrix 'b'
real (8), dimension(ai_leng, cj_leng), intent(out) ::  c ! input matrix 'c'
integer(4 )  ::  i, j, k
do i=1,ai_leng
  do j=1,cj_leng
    c(i,j) = 0.d0
    do k=1,bi_leng
      c(i,j) = c(i,j) + a(i,k)*b(k,j)
    enddo
  enddo
enddo
return
end subroutine  mul_ab
!############################################### mul_abt
subroutine  mul_abt( a, b, c, ai_leng, bj_leng, cj_leng  )
!    multiply matrix 'c' = 'a' * 'b't
!      c(ai_leng,cj_leng) = a(ai_leng,bj_leng) * b(cj_leng,bj_leng)
implicit    none
integer(4), intent(in)  ::  ai_leng !  1-st element length of array 'a'
integer(4), intent(in)  ::  bj_leng !  2-nd element length of array 'b'
integer(4), intent(in)  ::  cj_leng !  2-nd element length of array 'c'
real   (8), dimension(ai_leng, bj_leng), intent(in)  ::  a!   input matrix 'a'
real   (8), dimension(cj_leng, bj_leng), intent(in)  ::  b !  input matrix 'b'
real   (8), dimension(ai_leng, cj_leng), intent(out) ::  c!  input matrix 'c'
integer(4 )  ::  i, j, k
do i=1,ai_leng
  do j=1,cj_leng
    c(i,j) = 0.d0
    do k=1,bj_leng
      c(i,j) = c(i,j) + a(i,k)*b(j,k)
    enddo
  enddo
enddo
return
end subroutine  mul_abt
!############################################# sup_iccg
! Coppied from static_linear/sup_iccg.f90 on June 10, 2015
! here elm_k, duag, aiccg_u are complex
subroutine  sup_iccg ( &
&      elm_k, table_dof_elm, edof,                                       &
&      diag , istack_u   , item_u , aiccg_u, nodtot, item_u_tot     )
!    superpose symmetric element stiffness matrix to gloval stiffness
!    for iccg solver (lower element, upper whole stiffness)
implicit  none
integer(4),intent(in) :: edof, nodtot, item_u_tot
complex   (8),   intent(in)   ::  elm_k(edof,edof) !  element stiffness matrix
integer(4), intent(in)   :: table_dof_elm(edof)
!    digree of freedom number table at a element table_dof_elm(i)
!      where i    : dof order of 'elm_k'
complex(8), intent(inout) ::  diag(nodtot)                  ! diagonal value   (i-th dof)
integer(4), intent(in) ::  istack_u(0:item_u_tot) !  last term count at each freedom  (i-th dof)
integer(4), intent(in) ::  item_u(item_u_tot)       ! freedom number at each term      (i-th term)
complex(8), intent(inout) ::  aiccg_u(item_u_tot)      ! upper triangular k value         (i-th term)
integer(4)  ::  i_gl, j_gl, i_elm, j_elm
integer(4)  ::  num , i_pos
logical        ::  found
! * superpose element stiffness matrix
!      store diagonal and upper term for packed whole stiffness matrix
!       ( element stiffness matrix stored only lower triangle )
!
!    k(i_gl,j_gl) = k(i_gl,j_gl) + elm_k(i_elm,j_elm)
!
!   . make diagonal and upper triangle
!
      do i_elm=1,edof
         i_gl = table_dof_elm(i_elm)
         do j_elm=1,edof
            j_gl = table_dof_elm(j_elm)
            if      ( i_gl  == j_gl  ) then            ! diagonal
              diag(i_gl) = diag(i_gl) + elm_k(i_elm,j_elm)
            else if ( i_gl  <  j_gl  ) then            ! upper triangle
              found = .false.
!                                                 .. search term pos.
              do num=istack_u(i_gl-1)+1,istack_u(i_gl)
                if ( j_gl == item_u(num) ) then
                  i_pos =  num
                  found = .true.
                  exit
                endif
              enddo
              if ( .not.found ) then
                write(*,*) ' ***** error on sup_iccg : dof not found  ', i_gl, j_gl
!                call geofem_abort(34,'internal logic error')
                stop
              endif
!                                                 .. superpose the term
              if ( i_elm >  j_elm )  then              ! elm. lower
                aiccg_u(i_pos) = aiccg_u(i_pos) + elm_k(i_elm,j_elm)
              else                                     ! elm. upper(sym)
                aiccg_u(i_pos) = aiccg_u(i_pos) + elm_k(j_elm,i_elm)
              endif
            endif
         enddo
      enddo
      return
      end subroutine  sup_iccg
!############################################### COPY_UL_ICCG12
! Copied from static_linear/copy_ul_iccg.f90 on June 10, 2015
! Converted aiccg_u, aiccg_l, diag to complex on Aug. 21, 2015
      subroutine  copy_ul_iccg12(                                         &
     &     doftot, istack_u     , item_u , aiccg_u,                     &
     &             istack_l     , item_l , aiccg_l, item_u_tot, item_l_tot, ip          )
!    copy upper triangle term value to lower for iccg solver
      implicit  none
      integer(4),  intent(in)   :: doftot , ip ! total number of degree of freedom
	integer(4), intent(in)    :: item_u_tot, item_l_tot
      integer(4 ), intent(in)   :: istack_u(0:doftot)    ! last term count at each freedom  (i-th dof)
      integer(4 ), intent(in)   :: item_u(item_u_tot) ! freedom number at each term      (i-th term)
      complex(8), intent(in)   :: aiccg_u(item_u_tot) ! upper triangular k value         (i-th term)
      integer(4),  intent(in)   :: istack_l(0:doftot)     ! last term count at each freedom  (i-th dof)
      integer(4 ), intent(in)   ::   item_l(item_l_tot)  !  freedom number at each term      (i-th term)
      complex(8), intent(inout) ::  aiccg_l(item_l_tot)  !  lower triangular k value         (i-th term)
      integer(4 )  ::  i_gl, j_gl
      integer(4)  ::  num , num2, i_pos
      logical        ::  found
!  * copy upper triangle to lower triangle  (i_gl,j_gl) -> (j_gl,i_gl)
!
      do i_gl=1,doftot
         do num=istack_u(i_gl-1)+1,istack_u(i_gl)
              j_gl=item_u(num)
              found = .false.
!                                                 .. search term pos.
              do num2=istack_l(j_gl-1)+1,istack_l(j_gl)
                if ( i_gl == item_l(num2) ) then
                  i_pos =  num2
                  found = .true.
                  exit
                endif
              enddo
              if ( .not.found ) then
                write(*,*) ' ***** error on copy_ul_iccg: dof not found', i_gl, j_gl
!                call geofem_abort(34,'internal logic error')
                stop
              endif
!                                                 .. set the term
              aiccg_l(i_pos) = aiccg_u(num)
        enddo
      enddo
      if (ip .eq. 0 ) write(*,*) "### COPY_UL_ICCG12 END!! ### ip=",ip
      return
      end
!###############################################  SET_BC_ICCG
! This program is based on set_bc_iccg.f90 in GeoFEM
! Coded on Aug. 21, 2015
SUBROUTINE SET_BC_ICCG( aiccg_u, diag, item_u, istack_u, item_u_tot,  &
                                   & aiccg_l, item_l, istack_l, item_l_tot, doftot, rf, &
                                  &  dirichlet_value, dirichlet,  ip)
implicit none
integer(4),intent(in) :: doftot, item_u_tot, item_l_tot, ip
integer(4),intent(in) :: istack_u(0:doftot), item_u(item_u_tot)
integer(4),intent(in) :: istack_l(0:doftot), item_l(item_l_tot)
complex(8), intent(in), dimension(doftot) :: dirichlet_value
logical, intent(in), dimension(doftot) :: dirichlet
complex(8), intent(inout) ::  aiccg_u(item_u_tot), aiccg_l(item_l_tot), diag(doftot)
complex(8), intent(out)    :: rf(doftot)
integer(4) :: i, ipos
complex(8)      ::  temp
!#[1]## Initialize
!rf(1:doftot)=(0.d0, 0.d0)
!doftot=nodtot
!dirichlet(:)=.false.
!dirichlet_value(:)=(0.d0,0.d0)
!do i=1,nline_bc
!  dirichlet(line_bc(i))=.true.
!  dirichlet_value(line_bc(i))=Avalue_bc(i)
!end do
!do i=1,doftot
!write(*,*) "dirichlet_value(i)=",dirichlet_value(i),"i=",i
!end do
!#[2]##  modify right-hand vector
!     non-direchlet : {rf} = {rf} - [K]*{dirichlet_value}
!         direchlet : {rf} =            {dirichlet_value}
      do i=1,doftot
        if (dirichlet(i)) then
          rf(i) = dirichlet_value(i)
        else
          temp   =        diag   (i   ) * dirichlet_value(        i     )
          do ipos=istack_l(i-1)+1,istack_l(i)
            temp = temp + aiccg_l(ipos) * dirichlet_value( item_l(ipos) )
          enddo
          do ipos=istack_u(i-1)+1,istack_u(i)
            temp = temp + aiccg_u(ipos) * dirichlet_value( item_u(ipos) )
          enddo
            rf(i) = rf(i) - temp
        endif
      enddo

!#[3]## modify stiffness matrix
      do i=1,doftot
        if (dirichlet(i)) then
              diag   (i   ) = 1.d0
          do ipos=istack_l(i-1)+1,istack_l(i)
              aiccg_l(ipos) = 0.d0
          enddo
          do ipos=istack_u(i-1)+1,istack_u(i)
              aiccg_u(ipos) = 0.d0
          enddo
        else
          do ipos=istack_l(i-1)+1,istack_l(i)
            if (dirichlet(item_l(ipos))) then
              aiccg_l(ipos) = 0.d0
            endif
          enddo
          do ipos=istack_u(i-1)+1,istack_u(i)
            if (dirichlet(item_u(ipos))) then
              aiccg_u(ipos) = 0.d0
            endif
          enddo
        endif
      enddo
if (ip .eq. 0) write(*,*) "### SETBC END!! ###"
RETURN
END
!###############################################
subroutine OUTPERMUTEDLINES(n6line,xyzg,nodeg,line,nline, ntetg, n4g)
implicit none
integer(4),intent(in) :: nodeg, nline, line(2,nline), n6line(ntetg,6),ntetg,n4g(ntetg,5)
real(8),intent(in) :: xyzg(3,nodeg)
integer(4) :: i,j
integer(4) :: n1_1,n1_3,n1_4,n2_1,n2_2,n2_5,n3_2,n3_3,n3_6,n4_4,n4_5,n4_6
!#[1]## output "permutedline.msh"
open(1,file="permutedline.msh")
write(1,'(a)')"$MeshFormat"
write(1,'(a)')"2.2 0 8"
write(1,'(a)')"$EndMeshFormat"
write(1,'(a)')"$Nodes"
write(1,*) nodeg
write(1,'(i8,3g15.7)') (i,(xyzg(j,i),j=1,3),i=1,nodeg)
write(1,'(a)')"$EndNodes"
write(1,'(a)')"$Elements"
write(1,*) ntetg
do i=1,ntetg
 call getnode(n1_1,n2_1,n6line,ntetg,nline,line,i,1)
 call getnode(n2_2,n3_2,n6line,ntetg,nline,line,i,2)
 call getnode(n1_3,n3_3,n6line,ntetg,nline,line,i,3)
 call getnode(n1_4,n4_4,n6line,ntetg,nline,line,i,4)
 call getnode(n2_5,n4_5,n6line,ntetg,nline,line,i,5)
 call getnode(n3_6,n4_6,n6line,ntetg,nline,line,i,6)
 if ( n1_1 .eq. n1_3 .and. n1_1 .eq. n1_4 ) then
 if ( n2_1 .eq. n2_2 .and. n2_1 .eq. n2_5 ) then
 if ( n3_2 .eq. n3_3 .and. n3_2 .eq. n3_6 ) then
 if ( n4_4 .eq. n4_5 .and. n4_4 .eq. n4_6 ) then
 write(1,'(i8,a,5i8)') i," 4 2 0",n4g(i,1),n1_1,n2_1,n3_2,n4_4
 goto 100
 end if
 end if
 end if
 end if
 write(*,*) "### GEGEGE! ### itet=",i
 write(*,*) "n1_1,n1_3,n1_4=",n1_1,n1_3,n1_4
 write(*,*) "n2_1,n2_2,n2_5=",n2_1,n2_2,n2_5
 write(*,*) "n3_2,n3_3,n3_6=",n3_2,n3_3,n3_6
 write(*,*) "n4_4,n4_5,n4_6=",n4_4,n4_5,n4_6
 write(*,*) "n6line(itet,1)=",n6line(i,1)
 write(*,*) "n6line(itet,2)=",n6line(i,2)
 write(*,*) "n6line(itet,3)=",n6line(i,3)
 write(*,*) "n6line(itet,4)=",n6line(i,4)
 write(*,*) "n6line(itet,5)=",n6line(i,5)
 write(*,*) "n6line(itet,6)=",n6line(i,6)
 stop
 100 continue
end do
write(1,'(a)')"$EndElements"
close(1)

!#[2]## output "line, n6line"
open(1,file="lineinfo.dat")
write(1,*) nline
write(1,'(3i8)') (i,line(1,i),line(2,i),i=1,nline)
write(1,*) ntetg
write(1,'(7i8)') (i,(n6line(i,j),j=1,6),i=1,ntetg)
close(1)

write(*,*) "### OUTPERMUTEDLINES END!! ###"
return
end
!##
subroutine getnode(n1,n2,n6line,ntetg,nline,line,itet,iline)
implicit none
integer(4),intent(in) :: itet,iline,ntetg
integer(4),intent(in) :: n6line(ntetg,6),nline,line(2,nline)
integer(4),intent(out) :: n1, n2
if (n6line(itet,iline) .gt. 0 ) then
 n1=line(1,n6line(itet,iline))
 n2=line(2,n6line(itet,iline))
else ! n6line(itet,iline) is negative
 n1=line(2,-n6line(itet,iline))
 n2=line(1,-n6line(itet,iline))
end if
return
end
!---------------------------------------------------------
      SUBROUTINE  SOLVC2( A,Y,NSIZE,MBAND0,MBAND,IER,ISW )
!
!      SOLVE THE LINEAR EQUATION OF BAND MATRIX FORM
!
      IMPLICIT REAL*8  (A-H,O-Z)
      COMPLEX*16 A(MBAND0,1) , Y(1)
      COMPLEX*16 RAI , C , AC
!
!     NSIZE : SIZE OF THE EQUATION
!     MBAND : BAND WIDTH
!
!     DO 9 I = 1, NSIZE
!     DO 9 J = 1 , MBAND
!   9 A(J,I) = A(J,I) * 1.D+60
      N1 = NSIZE - 1
      IF( ISW.GT.0 ) GO TO 200
!
!      ****  FORWARD REDUCTION  ****
!
       DO 130 I = 1 , N1
	 !write(*,*) "I=",I,"A(1,I)=",A(1,I)
	 if (mod(i,100) .eq. 0 )write(*,*)"I=",I
       IF( A(1,I ).EQ.0. ) GO TO 800
          RAI = 1./ A(1,I)
          A(1,I) = RAI
          IF( I+MBAND-1-NSIZE.LE.0 ) MB = MBAND
          IF( I+MBAND-1-NSIZE.GT.0 ) MB = MB - 1
          DO 120 J = 2,MB
           C = RAI * A(J,I)
           DO 110 K = J , MB
             KKI = K - J + 1
             KKJ = I + J - 1
             IF( KKI.LT.1 ) GO TO 110
             IF( KKJ.GT.NSIZE ) GO TO 110
             A(KKI,KKJ) = A(KKI,KKJ)-C*A(K,I)
!            WRITE( * , 9876 ) K,I,KKI,KKJ
!9876        FORMAT( ' K,I,KKI,KKJ =',5I7 )
  110      CONTINUE
!          WRITE( * , 8765 ) J , I , C
!8765      FORMAT( ' J,I =',2I7,5X,2D12.4 )
           A(J,I) = C
  120     CONTINUE
!         WRITE( * , 7654 ) I
!7654 FORMAT( ' NODE NUMBE =',I7 )
  130  CONTINUE
!       IF( A(1,NSIZE).EQ.(0.0,0.0) ) GO TO 801
        WRITE( * , 5500 )
 5500   FORMAT( ' ** END OF FORWARD REDUCTION ** ' )
  200  CONTINUE
!      ****   PRE-PROCESSING FOR BACKWARD SUBSTITUTION  ****
       DO 230 I = 1 , N1
          IF( I+MBAND-1-NSIZE.LE.0 ) MB = MBAND
          IF( I+MBAND-1-NSIZE.GT.0 ) MB = MB - 1
          DO 220 J = 2 , MB
             KKI = I + J - 1
             IF( KKI.GT.NSIZE ) GO TO 220
             Y(KKI) = Y(KKI) - A(J,I)*Y(I)
  220     CONTINUE
          Y(I) = Y(I)*A(1,I)
  230  CONTINUE
       Y(NSIZE) = Y(NSIZE)/A(1,NSIZE)
!      ****  BACKWARD SUBSTITUTION  ****
       DO 320 N = 2 , NSIZE
          DO 310 J = 2 , MBAND
            IF( J.GT.N ) GO TO 310
            KKJ = NSIZE - N + 1
            KKN = NSIZE - N + J
            Y(KKJ) = Y(KKJ) - A(J,KKJ)*Y(KKN)
  310     CONTINUE
  320  CONTINUE
       IER = 0
       WRITE( * , 3387 )
 3387 FORMAT( ' *** END OF SOLVC2 *** ' )
       return
  800  IER = I
       goto 999
  801  IER = NSIZE
  999  continue
      IF( IER.NE.0 ) THEN
        WRITE( * , 3389 ) IER
 3389   FORMAT( '    ???  ERROR IN SOLVC2  ERROR CODE =',I8 )
        STOP
      END IF

       RETURN
       END
!
!----------------------------------------------------------------------
!
!
       SUBROUTINE SETBC( A , V ,MB0, MB , NODE , IB , IBC , VIBC )
       IMPLICIT REAL*8 (A-H,O-Z)
       COMPLEX*16    A(MB0,NODE) , V(NODE) , VIBC(IB) , VP
       DIMENSION     IBC(IB)
        DO 300 I=1,IB
           N5=IBC(I)
           VP=VIBC(I)
           DO 300 J =1,NODE
                KJ=IABS(J-N5) + 1
                IF (KJ.GT.MB) GO TO 300
                IF ( J-N5 ) 500,600,700
  500           V(J)=V(J)-A(KJ,J)*VP
                A(KJ,J)=(0.,0.)
                GO TO 300
  600           V(N5) = VP
                A(1,N5)=(1.,0.)
                GO TO 300
  700           V(J) = V(J) - A(KJ,N5)*VP
                A(KJ,N5)=(0.,0.)
  300 CONTINUE
      RETURN
      END

